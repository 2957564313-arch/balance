
C251 COMPILER V5.60.0,  zf_common_debug                                                    24/01/26  11:15:46  PAGE 1   

C251 COMPILER V5.60.0, COMPILATION OF MODULE zf_common_debug
OBJECT MODULE PLACED IN .\out_file\zf_common_debug.obj
COMPILER INVOKED BY: C:\Keil_v5\C251\BIN\C251.EXE ..\..\libraries\zf_common\zf_common_debug.c LARGE NOALIAS WARNINGLEVEL
                    -(3) OPTIMIZE(0,SIZE) BROWSE INCDIR(..\..\libraries\zf_common;..\..\libraries\zf_components;..\..\libraries\zf_device;..\
                    -..\libraries\zf_driver;..\user;..\code) DEBUG PRINT(.\out_file\zf_common_debug.lst) OBJECT(.\out_file\zf_common_debug.ob
                    -j) 

stmt  level    source

    1          /********************************************************************************************************
             -*************
    2          * STC32G Opensourec Library 即（STC32G 开源库）是一个基于官方 SDK 接口的第三方开源库
    3          * Copyright (c) 2022 SEEKFREE 逐飞科技
    4          *
    5          * 本文件是STC 开源库的一部分
    6          *
    7          * STC32G 开源库 是免费软件
    8          * 您可以根据自由软件基金会发布的 GPL（GNU General Public License，即 GNU通用公共许可证）的条款
    9          * 即 GPL 的第3版（即 GPL3.0）或（您选择的）任何后来的版本，重新发布和/或修改它
   10          *
   11          * 本开源库的发布是希望它能发挥作用，但并未对其作任何的保证
   12          * 甚至没有隐含的适销性或适合特定用途的保证
   13          * 更多细节请参见 GPL
   14          *
   15          * 您应该在收到本开源库的同时收到一份 GPL 的副本
   16          * 如果没有，请参阅<https://www.gnu.org/licenses/>
   17          *
   18          * 额外注明：
   19          * 本开源库使用 GPL3.0 开源许可证协议 以上许可申明为译文版本
   20          * 许可申明英文版在 libraries/doc 文件夹下的 GPL3_permission_statement.txt 文件中
   21          * 许可证副本在 libraries 文件夹下 即该文件夹下的 LICENSE 文件
   22          * 欢迎各位使用并传播本程序 但修改内容时必须保留逐飞科技的版权声明（即本声明）
   23          *
   24          * 文件名称          
   25          * 公司名称          成都逐飞科技有限公司
   26          * 版本信息          查看 libraries/doc 文件夹内 version 文件 版本说明
   27          * 开发环境          MDK FOR C251
   28          * 适用平台          STC32G
   29          * 店铺链接          https://seekfree.taobao.com/
   30          *
   31          * 修改记录
   32          * 日期              作者           备注
   33          * 2024-08-01        大W            first version
   34          *********************************************************************************************************
             -***********/
   35          #include "zf_common_fifo.h"
   36          #include "zf_common_debug.h"
   37          #include "zf_common_clock.h"
   38          #include "zf_common_interrupt.h"
   39          #include "zf_common_typedef.h"
   40          
   41          #include "zf_driver_uart.h"
   42          #include "zf_driver_delay.h"
   43          
   44          #pragma warning disable = 183
   45          #pragma warning disable = 177
   46          
   47          #if DEBUG_UART_USE_INTERRUPT                                                    // 如果启用 debug uart 接
             -收中断
   48          uint8                       debug_uart_buffer[DEBUG_RING_BUFFER_LEN];           // 数据存放数组
   49          #endif
   50          
   51          fifo_struct                 debug_uart_fifo;
   52          
   53          //static debug_output_struct  debug_output_info;

C251 COMPILER V5.60.0,  zf_common_debug                                                    24/01/26  11:15:46  PAGE 2   
   54          static volatile uint8       zf_debug_init_flag = 1;
   55          static volatile uint8       zf_debug_assert_enable = 1;
   56          
   57          ////-----------------------------------------------------------------------------------------------------
             ---------------
   58          //// 函数简介      debug 软延时函数 在 120MHz 下是一秒多的时间 各单片机需要根据各自时钟试验
   59          //// 参数说明     pass        判断是否触发断言
   60          //// 参数说明     *file       文件名
   61          //// 参数说明     line        目标行数
   62          //// 返回参数     void
   63          ////-----------------------------------------------------------------------------------------------------
             ---------------
   64          //static void debug_delay (void)
   65          //{
   66          //    vuint32 loop_1 = 0, loop_2 = 0;
   67          //    for(loop_1 = 0; loop_1 <= 0xFF; loop_1 ++)
   68          //        for(loop_2 = 0; loop_2 <= 0x1FF; loop_2 ++)
   69          //            _nop_();
   70          //}
   71          
   72          
   73          ////-----------------------------------------------------------------------------------------------------
             ---------------
   74          //// 函数简介     debug 保护处理 主要是防止断言后出现信号维持而导致硬件失控
   75          //// 参数说明     void
   76          //// 返回参数     void
   77          //// 使用示例     debug_protective_handler();
   78          //// 备注信息     本函数在文件内部调用 用户不用关注 也不可修改
   79          ////-----------------------------------------------------------------------------------------------------
             ---------------
   80          //static void debug_protective_handler (void)
   81          //{
   82          //   // 暂未更新
   83          //}
   84          
   85          ////-----------------------------------------------------------------------------------------------------
             ---------------
   86          //// 函数简介      debug 串口输出接口 此部分不允许用户更改
   87          //// 参数说明     *str        需要输出的字符串
   88          //// 返回参数     void
   89          //// 使用示例     debug_uart_str_output("Log message");
   90          //// 备注信息     本函数在文件内部调用 用户不用关注 也不可修改
   91          ////-----------------------------------------------------------------------------------------------------
             ---------------
   92          //static void debug_uart_str_output (const char *str)
   93          //{
   94          //    uart_write_string(DEBUG_UART_INDEX, str);
   95          //}
   96          
   97          ////-----------------------------------------------------------------------------------------------------
             ---------------
   98          //// 函数简介     debug 输出接口
   99          //// 参数说明     *type       log 类型
  100          //// 参数说明     *file       文件名
  101          //// 参数说明     line        目标行数
  102          //// 参数说明     *str        信息
  103          //// 返回参数     void
  104          //// 使用示例     debug_output("Log message", file, line, str);
  105          //// 备注信息     本函数在文件内部调用 用户不用关注 也不可修改
  106          ////-----------------------------------------------------------------------------------------------------
             ---------------
  107          //static void debug_output (char *type, char *file, int line, char *str)
  108          //{
  109          //    char *file_str;
  110          
  111          //    vuint16 i = 0, j = 0;

C251 COMPILER V5.60.0,  zf_common_debug                                                    24/01/26  11:15:46  PAGE 3   
  112          //    vint16 len_origin = 0;
  113          //    vuint16 show_len = 0;
  114          //    vint16 show_line_index = 0;
  115          //      
  116          //      volatile char output_buffer[256] = {0};
  117          //    volatile char file_path_buffer[64] = {0};
  118          
  119          //    len_origin = strlen(file);
  120          
  121          
  122          
  123          //    if(debug_output_info.type_index)
  124          //    {
  125          //        debug_output_info.output_screen_clear();
  126          //    }
  127          
  128          //    if(zf_debug_init_flag)
  129          //    {
  130          //        if(debug_output_info.type_index)
  131          //        {
  132          //            // 需要分行将文件的路径和行数输出
  133          //            // <不输出完整路径 只输出一级目录 例如 src/main.c>
  134          //            // 输出 line : xxxx
  135          //            debug_output_info.output_screen(0, show_line_index ++, type);
  136          
  137          //            file_str = file;
  138          //            len_origin = strlen(file);
  139          //            show_len = (debug_output_info.display_x_max / debug_output_info.font_x_size);
  140          
  141          //            while(*file_str++ != '\0');
  142          
  143          //            // 只取一级目录 如果文件放在盘符根目录 或者 MDK 的工程根目录 就会直接输出当前目录
  144          //            for(j = 0; (j < 2) && (len_origin >= 0); len_origin --)             // 查找两个 '/'
  145          //            {
  146          //                file_str --;
  147          //                if((*file_str == '/') || (*file_str == 0x5C))
  148          //                {
  149          //                    j ++;
  150          //                }
  151          //            }
  152          
  153          //            // 文件路径保存到数组中
  154          //            if(len_origin >= 0)
  155          //            {
  156          //                file_str ++;
  157          //                sprintf(output_buffer, "file: %s", file_str);
  158          //            }
  159          //            else
  160          //            {
  161          //                if(0 == j)
  162          //                {
  163          //                    sprintf(output_buffer, "file: mdk/%s", file_str);
  164          //                }
  165          //                else
  166          //                {
  167          //                    sprintf(output_buffer, "file: %s", file_str);
  168          //                }
  169          //            }
  170          
  171          //            // 屏幕显示路径
  172          //            for(i = 0; i < ((strlen(output_buffer) / show_len) + 1); i ++)
  173          //            {
  174          //                for(j = 0; j < show_len; j ++)
  175          //                {
  176          //                    if(strlen(output_buffer) < (j + i * show_len))
  177          //                    {

C251 COMPILER V5.60.0,  zf_common_debug                                                    24/01/26  11:15:46  PAGE 4   
  178          //                        break;
  179          //                    }
  180          //                    file_path_buffer[j] = output_buffer[j + i * show_len];
  181          //                }
  182          
  183          //                file_path_buffer[j] = '\0';                                     // 末尾添加\0
  184          
  185          //                debug_output_info.output_screen(0, debug_output_info.font_y_size * show_line_index ++, 
             -file_path_buffer);
  186          //            }
  187          
  188          //            // 屏幕显示行号
  189          //            sprintf(output_buffer, "line: %d", line);
  190          //            debug_output_info.output_screen(0, debug_output_info.font_y_size * show_line_index ++, outp
             -ut_buffer);
  191          
  192          //            // 屏幕显示 Log 如果有的话
  193          //            if(NULL != str)
  194          //            {
  195          //                for(i = 0; i < ((strlen(str) / show_len) + 1); i ++)
  196          //                {
  197          //                    for(j = 0; j < show_len; j ++)
  198          //                    {
  199          //                        if(strlen(str) < (j + i * show_len))
  200          //                        {
  201          //                            break;
  202          //                        }
  203          //                        file_path_buffer[j] = str[j + i * show_len];
  204          //                    }
  205          
  206          //                    file_path_buffer[j] = '\0';                                 // 末尾添加\0
  207          
  208          //                    debug_output_info.output_screen(0, debug_output_info.font_y_size * show_line_index 
             -++, file_path_buffer);
  209          //                }
  210          //            }
  211          //        }
  212          //        else
  213          //        {
  214          //                      printf("\r\n %s file %s line %d\r\n", type, file, line);
  215          
  216          ////            memset(output_buffer, 0, 256);
  217          ////            debug_output_info.output_uart(type);
  218          ////            if(NULL != str)
  219          ////            {
  220          ////                sprintf(output_buffer, "\r\nfile %s line %d: %s.\r\n", file, line, str);
  221          ////            }
  222          ////            else
  223          ////            {
  224          ////                sprintf(output_buffer, "\r\nfile %s line %d.\r\n", file, line);
  225          ////            }
  226          ////            debug_output_info.output_uart(output_buffer);
  227          //        }
  228          //    }
  229          //}
  230          
  231          
  232          //-------------------------------------------------------------------------------------------------------
             -------------
  233          // 函数简介     调试串口发送缓冲区
  234          // 参数说明     *buff       读出数据存放的数组指针
  235          // 参数说明     len         需要发送的长度
  236          // 返回参数     uint32      剩余未发送的长度
  237          // 使用示例
  238          // 备注信息     本函数需要开启 DEBUG_UART_USE_INTERRUPT 宏定义才可使用
  239          //-------------------------------------------------------------------------------------------------------

C251 COMPILER V5.60.0,  zf_common_debug                                                    24/01/26  11:15:46  PAGE 5   
             -------------
  240          uint32 debug_send_buffer(const uint8 *buff, uint32 len)
  241          {
  242   1              if(len > 0xFFFF)
  243   1              {
  244   2                      uart_write_buffer(DEBUG_UART_INDEX, buff, 0xFFFF);
  245   2                      return  len - 0xFFFF;
  246   2              }
  247   1              else
  248   1              {
  249   2                      uart_write_buffer(DEBUG_UART_INDEX, buff, (uint16)len);
  250   2              }
  251   1          
  252   1          return 0;
  253   1      }
  254          
  255          
  256          
  257          //-------------------------------------------------------------------------------------------------------
             -------------
  258          // 函数简介     读取 debug 环形缓冲区数据
  259          // 参数说明     *buff       读出数据存放的数组指针
  260          // 参数说明     len         需要读取的长度
  261          // 返回参数     uint32      读出数据的实际长度
  262          // 使用示例
  263          // 备注信息     本函数需要开启 DEBUG_UART_USE_INTERRUPT 宏定义才可使用
  264          //-------------------------------------------------------------------------------------------------------
             -------------
  265          uint32 debug_read_buffer (uint8 *buff, uint32 len)
  266          {
  267   1          fifo_read_buffer(&debug_uart_fifo, buff, &len, FIFO_READ_AND_CLEAN);
  268   1      
  269   1          return len;
  270   1      }
  271          
  272          #if DEBUG_UART_USE_INTERRUPT                                                    // 条件编译 只有在启用串?
             -谥卸喜疟嘁?
  273          //-------------------------------------------------------------------------------------------------------
             -------------
  274          // 函数简介     debug 串口中断处理函数 isr.c 中对应串口中断服务函数调用
  275          // 参数说明     void
  276          // 返回参数     void
  277          // 使用示例     debug_interrupr_handler();
  278          // 备注信息     本函数需要开启 DEBUG_UART_USE_INTERRUPT 宏定义才可使用
  279          //              并且本函数默认放置在 UART1 的串口接收中断处理处
  280          //-------------------------------------------------------------------------------------------------------
             -------------
  281          void debug_interrupr_handler (uint8 dat)
  282          {
  283   1              if(zf_debug_init_flag)
  284   1              {
  285   2                      uart_query_byte(DEBUG_UART_INDEX, &dat);                    // 读取串口数据
  286   2                      fifo_write_buffer(&debug_uart_fifo, &dat, 1);               // 存入 FIFO
  287   2              }
  288   1      
  289   1      }
  290          
  291          #endif
  292          
  293          //-------------------------------------------------------------------------     // printf 重定向 此部分不
             -允许用户更改
  294          //-------------------------------------------------------------------------------------------------------
             -------------
  295          // 函数简介     printf重定向
  296          // 参数说明     void
  297          // 返回参数     void

C251 COMPILER V5.60.0,  zf_common_debug                                                    24/01/26  11:15:46  PAGE 6   
  298          //  @since      v1.0
  299          // 备注信息              重定向printf到DEBUG串口上
  300          //-------------------------------------------------------------------------------------------------------
             -------------
  301          #if(1 == PRINTF_ENABLE)      //初始化调试串口
  302          //重定义printf 数字 只能输出uint16
  303          char putchar(char c)
  304          {
  305   1          uart_write_byte(DEBUG_UART_INDEX, c);//把自己实现的串口打印一字节数据的函数替换到这里
  306   1      
  307   1          return c;
  308   1      }
  309          #endif
  310          //-------------------------------------------------------------------------     // printf 重定向 此部分不
             -允许用户更改
  311          
  312          ////-----------------------------------------------------------------------------------------------------
             ---------------
  313          //// 函数简介     启用断言
  314          //// 参数说明     void
  315          //// 返回参数     void
  316          //// 使用示例     debug_assert_enable();
  317          //// 备注信息     断言默认开启 建议开启断言
  318          ////-----------------------------------------------------------------------------------------------------
             ---------------
  319          //void debug_assert_enable (void)
  320          //{
  321          //    zf_debug_assert_enable = 1;
  322          //}
  323          
  324          ////-----------------------------------------------------------------------------------------------------
             ---------------
  325          //// 函数简介      禁用断言
  326          //// 参数说明     void
  327          //// 返回参数     void
  328          //// 使用示例     debug_assert_disable();
  329          //// 备注信息     断言默认开启 不建议禁用断言
  330          ////-----------------------------------------------------------------------------------------------------
             ---------------
  331          //void debug_assert_disable (void)
  332          //{
  333          //    zf_debug_assert_enable = 0;
  334          //}
  335          
  336          //-------------------------------------------------------------------------------------------------------
             -------------
  337          // 函数简介      debug 断言处理函数 此部分不允许用户更改
  338          // 参数说明     pass        判断是否触发断言
  339          // 参数说明     *file       文件名
  340          // 参数说明     line        目标行数
  341          // 返回参数     void
  342          // 使用示例     zf_assert(0);
  343          // 备注信息     这个函数不是直接调用的 此部分不允许用户更改
  344          //              使用 zf_commmon_debug.h 中的 zf_assert(x) 接口
  345          //-------------------------------------------------------------------------------------------------------
             -------------
  346          void debug_assert_handler (uint8 pass, char *file, int line)
  347          {
  348   1              uint8 log_str[] = "Assert error";
  349   1      
  350   1              while(!pass)
  351   1              {
  352   2                      // 如果代码跳转到这里停住了
  353   2                      // 一般你的函数参数传递出错了
  354   2                      // 或者你自己调用的 zf_assert(x) 接口处报错了
  355   2      

C251 COMPILER V5.60.0,  zf_common_debug                                                    24/01/26  11:15:46  PAGE 7   
  356   2                      // 如果调用了 debug_init 初始化了 log 输出
  357   2                      // 就在对应串口输出去查看是哪个文件的哪一行报错
  358   2      
  359   2                      // 如果没有初始化 debug
  360   2                      // 那就看看这个 file 的字符串值和 line 的行数
  361   2                      // 那代表报错的文件路径名称和对应报错行数
  362   2      
  363   2                      // 再去调试看看是为什么参数出错
  364   2      
  365   2      
  366   2                      printf("\r\n %s file %s line %d\r\n", log_str, file, line);
  367   2      
  368   2      
  369   2                      system_delay_ms(500);
  370   2              }
  371   1      }
  372          
  373          ////-----------------------------------------------------------------------------------------------------
             ---------------
  374          //// 函数简介      debug 调试信息处理函数 此部分不允许用户更改
  375          //// 参数说明     bool        判断是否触发断言
  376          //// 参数说明     *str        要输出的调试信息
  377          //// 参数说明     *file       文件名
  378          //// 参数说明     line        目标行数
  379          //// 返回参数     void
  380          //// 使用示例     printf( "Log Message");
  381          //// 备注信息     这个函数不是直接调用的 此部分不允许用户更改
  382          ////              使用 zf_commmon_debug.h 中的 zf_log(x, str) 接口
  383          ////-----------------------------------------------------------------------------------------------------
             ---------------
  384          //void debug_log_handler (uint8 pass, char *str, char *file, int line)
  385          //{
  386          //      uint8 log_str[] = "Log message";
  387          //    do
  388          //    {
  389          //        if(pass)
  390          //        {
  391          //            break;
  392          //        }
  393          //        if(zf_debug_init_flag)
  394          //        {
  395          //            debug_output(log_str, file, line, str);
  396          ////            printf("Log message from %s line %d :\"%s\".\r\n", file, line, str);
  397          //        }
  398          //    }while(0);
  399          //}
  400          
  401          ////-----------------------------------------------------------------------------------------------------
             ---------------
  402          //// 函数简介      debug 输出绑定信息初始化 此部分不允许用户更改
  403          //// 参数说明     *info       debug 输出的信息结构体
  404          //// 返回参数     void
  405          //// 使用示例            debug_output_struct_init(info);
  406          ////-----------------------------------------------------------------------------------------------------
             ---------------
  407          //void debug_output_struct_init (debug_output_struct *info)
  408          //{
  409          //    info->type_index            = 0;
  410          
  411          //    info->display_x_max         = 0xFFFF;
  412          //    info->display_y_max         = 0xFFFF;
  413          
  414          //    info->font_x_size           = 0xFF;
  415          //    info->font_y_size           = 0xFF;
  416          
  417          //    info->output_uart           = NULL;

C251 COMPILER V5.60.0,  zf_common_debug                                                    24/01/26  11:15:46  PAGE 8   
  418          //    info->output_screen         = NULL;
  419          //    info->output_screen_clear   = NULL;
  420          //}
  421          
  422          ////-----------------------------------------------------------------------------------------------------
             ---------------
  423          //// 函数简介      debug 输出绑定初始化 此部分不允许用户更改
  424          //// 参数说明     *info       debug 输出的信息结构体
  425          //// 返回参数     void
  426          //// 使用示例     debug_output_init(info);
  427          //// 备注信息     这个函数一般不由用户调用
  428          ////-----------------------------------------------------------------------------------------------------
             ---------------
  429          //void debug_output_init (debug_output_struct *info)
  430          //{
  431          //    debug_output_info.type_index            = info->type_index;
  432          
  433          //    debug_output_info.display_x_max         = info->display_x_max;
  434          //    debug_output_info.display_y_max         = info->display_y_max;
  435          
  436          //    debug_output_info.font_x_size           = info->font_x_size;
  437          //    debug_output_info.font_y_size           = info->font_y_size;
  438          
  439          //    debug_output_info.output_uart           = info->output_uart;
  440          //    debug_output_info.output_screen         = info->output_screen;
  441          //    debug_output_info.output_screen_clear   = info->output_screen_clear;
  442          
  443          //    zf_debug_init_flag = 1;
  444          //}
  445          
  446          //-------------------------------------------------------------------------------------------------------
             -------------
  447          // 函数简介      debug 串口初始化 此部分不允许用户更改
  448          // 参数说明     void
  449          // 返回参数     void
  450          // 使用示例     debug_init();
  451          // 备注信息     开源库示例默认调用 但默认禁用中断接收
  452          //-------------------------------------------------------------------------------------------------------
             -------------
  453          void debug_init (void)
  454          {
  455   1              uint8 uartx = DEBUG_UART_INDEX;
  456   1      //    debug_output_struct info;
  457   1      //    debug_output_struct_init(&info);
  458   1      //    info.output_uart = debug_uart_str_output;
  459   1      //    debug_output_init(&info);
  460   1      
  461   1          uart_init(
  462   1              DEBUG_UART_INDEX,                                                       // 在 zf_common_debug.h ?
             -胁榭炊杂χ?
  463   1              DEBUG_UART_BAUDRATE,                                                    // 在 zf_common_debug.h ?
             -胁榭炊杂χ?
  464   1              DEBUG_UART_TX_PIN,                                                      // 在 zf_common_debug.h ?
             -胁榭炊杂χ?
  465   1              DEBUG_UART_RX_PIN);                                                     // 在 zf_common_debug.h ?
             -胁榭炊杂χ?
  466   1      
  467   1      #if DEBUG_UART_USE_INTERRUPT                                                    // 条件编译 只有在启用串?
             -谥卸喜疟嘁?
  468   1          fifo_init(&debug_uart_fifo, FIFO_DATA_8BIT, debug_uart_buffer, DEBUG_RING_BUFFER_LEN);
  469   1          uart_rx_interrupt(DEBUG_UART_INDEX, 1);                                     // 使能对应串口接收中断
  470   1      
  471   1              // 设置串口回调函数
  472   1              if(uartx == UART_1)                             
  473   1          {
  474   2              uart1_irq_handler = debug_interrupr_handler;

C251 COMPILER V5.60.0,  zf_common_debug                                                    24/01/26  11:15:46  PAGE 9   
  475   2          }
  476   1          else if(uartx == UART_2)
  477   1          {
  478   2              uart2_irq_handler = debug_interrupr_handler;
  479   2          }
  480   1          else if(uartx == UART_3)
  481   1          {
  482   2              uart3_irq_handler = debug_interrupr_handler;
  483   2          }
  484   1          else if(uartx == UART_4)
  485   1          {
  486   2              uart4_irq_handler = debug_interrupr_handler;
  487   2          }
  488   1      
  489   1      #endif
  490   1      
  491   1      }
  492          
  493          
  494          
  495          


Module Information          Static   Overlayable
------------------------------------------------
  code size            =       547     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =       128     ------
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =        49     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

