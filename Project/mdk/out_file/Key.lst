C251 COMPILER V5.60.0,  Key                                                                24/01/26  14:43:44  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE Key
OBJECT MODULE PLACED IN .\out_file\Key.obj
COMPILER INVOKED BY: C:\Keil_v5\C251\BIN\C251.EXE ..\code\Key.c LARGE NOALIAS WARNINGLEVEL(3) OPTIMIZE(0,SIZE) BROWSE IN
                    -CDIR(..\..\libraries\zf_common;..\..\libraries\zf_components;..\..\libraries\zf_device;..\..\libraries\zf_driver;..\user
                    -;..\code) DEBUG PRINT(.\out_file\Key.lst) OBJECT(.\out_file\Key.obj) 

stmt  level    source

    1          #include "zf_common_headfile.h"                  // Device header
    2          
    3          #include "Key.h"                //ä½¿ç”¨äº†ä½äºKey.hçš„å®å®šä¹‰
    4          
    5          //ç”¨å®å®šä¹‰æ›¿æ¢1/0ï¼Œä¾¿äºç†è§£Key_GetStateï¼ˆï¼‰
    6          #define KEY_PRESSED                     1
    7          #define KEY_UNPRESSED                   0
    8          
    9          //å®å®šä¹‰æ›¿æ¢æ—¶é—´é˜ˆå€?
   10          /*
   11          è¯´æ˜ï¼šç”±äºæŒ‰é”®æ£€æµ‹å’ŒçŠ¶æ€æœºä»£ç æ¯éš”20msæ‰ä¼šæ‰§è¡Œä¸€æ¬?
   12          æ‰€ä»¥æ­¤å¤„çš„å„ä¸ªæ—¶é—´é˜ˆå€¼æœ€å¥½éƒ½è®¾ç½®ä¸?0msçš„å€æ•°
   13          æ‰€ä»¥å³ä½¿è®¾å®šæ—¶é—´ä¸º50msï¼Œä½†å®é™…å´ä¼šæ˜?0ms
   14          */
   15          #define KEY_Time_DOUBLE                 0
   16          #define KEY_Time_LONG                   2000
   17          #define KEY_Time_REPEAT                 100
   18          
   19          uint8 Key_Flag[KEY_COUNT];//ä¸åŒçš„ä½è¡¨ç¤ºä¸åŒçš„äº‹ä»¶æ ‡å¿—ä½
   20          
   21          // å®šä¹‰æŒ‰é”®å¼•è„š
   22          #define KEY1_PIN    IO_P70
   23          #define KEY2_PIN    IO_P71
   24          #define KEY3_PIN    IO_P72
   25          #define KEY4_PIN    IO_P73
   26          
   27          void Key_Init(void)
   28          {
   29   1              gpio_init(KEY1_PIN, GPI, 1, GPI_PULL_UP);
   30   1              gpio_init(KEY2_PIN, GPI, 1, GPI_PULL_UP);
   31   1              gpio_init(KEY3_PIN, GPI, 1, GPI_PULL_UP);
   32   1              gpio_init(KEY4_PIN, GPI, 1, GPI_PULL_UP);
   33   1      }
   34          
   35          //å½¢å‚æŒ‡å®šæŒ‰é”®ï¼›è¿”å›å½“å‰æŒ‰é”®æŒ‰ä¸‹çŠ¶æ€?æœªæŒ‰ä¸‹çŠ¶æ€?
   36          uint8 Key_GetState(uint8 n)
   37          {
   38   1              if (n == 0)
   39   1              {
   40   2                      if (gpio_get_level(KEY1_PIN) == 0)//æŒ‰ä¸‹
   41   2                      {
   42   3                      return KEY_PRESSED;//è¿”å›æŒ‰ä¸‹
   43   3                      }
   44   2                      return KEY_UNPRESSED;//è¿”å›æœªæŒ‰ä¸?
   45   2              }
   46   1              else if (n == 1)
   47   1              {
   48   2                      if (gpio_get_level(KEY2_PIN) == 0)//æŒ‰ä¸‹
   49   2                      {
   50   3                      return KEY_PRESSED;
   51   3                      }
   52   2                      return KEY_UNPRESSED;
   53   2          }
   54   1              else if (n == 2)
   55   1              {
   56   2                      if (gpio_get_level(KEY3_PIN) == 0)//æŒ‰ä¸‹
   57   2                      {
C251 COMPILER V5.60.0,  Key                                                                24/01/26  14:43:44  PAGE 2   

   58   3                      return KEY_PRESSED;
   59   3                      }
   60   2                      return KEY_UNPRESSED;
   61   2              }
   62   1          else if (n == 3)
   63   1              {
   64   2                      if (gpio_get_level(KEY4_PIN) == 0)//æŒ‰ä¸‹
   65   2                      {
   66   3                      return KEY_PRESSED;
   67   3                      }
   68   2                      return KEY_UNPRESSED;
   69   2              }
   70   1              else
   71   1              {
   72   2                      return 0;
   73   2              }
   74   1      }
   75          
   76          //ç¬¬ä¸€ä¸ªå‚æ•°æŒ‡å®šæŒ‰é’?
   77          //ç¬¬äºŒä¸ªå‚æ•°æŒ‡å®šæ ‡å¿—ä½;æ ¼å¼ï¼?xXX
   78          uint8 Key_Check(uint8 n, uint8 Flag)
   79          {
   80   1              //ä¸€ä¸ªå˜é‡?ä½æ©ç ?
   81   1              //ä¾‹å¦‚ï¼šå˜é‡?0x01ï¼Œå¦‚æœæœ€ä½ä½æ˜?ï¼Œåˆ™ç»“æœä¸?x01
   82   1              //                                 å¦‚æœæœ€ä½ä½æ˜?ï¼Œåˆ™ç»“æœä¸?x00
   83   1              //              å˜é‡&0x02ï¼Œå¦‚æœæ¬¡ä½ä½æ˜?ï¼Œåˆ™ç»“æœä¸?x02
   84   1              //                                 å¦‚æœæ¬¡ä½ä½æ˜¯0ï¼Œåˆ™ç»“æœä¸?x00
   85   1              //æ³¨æ„ï¼ŒæŒ‡å®šä½ä¸?æ—¶ï¼Œç»“æœæ˜¯ä½æ©ç æœ¬èº«(é?)ï¼Œè€Œä¸ä¸€å®šæ˜¯0x01
   86   1              if (Key_Flag[n] & Flag)
   87   1              {
   88   2                      if (Flag != KEY_HOLD)//æ£€æµ‹æŒ‡å®šä½æ˜¯å¦ä¸ºKEY_HOLD
   89   2                      {
   90   3                              //æ¸…é›¶KEY_HOLDï¼›å…¶ä»–æ ‡å¿—ä½åœ¨ä¸»ç¨‹åºè¯»åæ¸…é›¶
   91   3                              Key_Flag[n] &= ~Flag;
   92   3                      }
   93   2                      return 1;//æŒ‡å®šæ ‡å¿—ä½æ˜¯1
   94   2              }
   95   1              return 0;//æŒ‡å®šæ ‡å¿—ä½æ˜¯0
   96   1      }
   97          
   98          void Key_Tick(void)//åˆ©ç”¨å®šæ—¶ä¸­æ–­è°ƒç”¨ï¼Œè·å–é€šç”¨çš„æ—¶é—´åŸºå‡?
   99          {
  100   1              static uint8 Count;//å®šä¹‰é™æ€å˜é‡?
  101   1              static uint8 i;//ç”¨äºéå†,æŒ‰é”®å°‘æ—¶å¯ä»¥è¿™ä¹ˆå¹?
  102   1              static uint8 CurrState[KEY_COUNT],PrevState[KEY_COUNT];//Current,Previous
  103   1              static uint8 S[KEY_COUNT];//çŠ¶æ€å˜é‡ï¼ŒåŒæ±ŸåçŠ¶æ€è½¬ç§»å›¾
  104   1              static uint16 Time[KEY_COUNT];//é•¿æŒ‰/åŒå‡» è®¡æ—¶å™¨ï¼ˆæ­¤å¤„é€’å‡è®¡æ—¶ï¼?
  105   1              //é™æ€å˜é‡é»˜è®¤å€¼ä¸º0ï¼Œå‡½æ•°é€€å‡ºåå€¼ä¸ä¼šä¸¢å¤?
  106   1              
  107   1              for (i = 0;i < KEY_COUNT; i ++)
  108   1              {
  109   2                      if  (Time[i] > 0)
  110   2                      {
  111   3                              Time[i] --;
  112   3                      }
  113   2              }
  114   1              Count++;//è®¡æ•°åˆ†é¢‘
  115   1              if (Count >= 20)//å¯è¿‡æ»¤æŒ‰é”®æŠ–åŠ¨ï¼ŒæŒ‰éœ€è°ƒæ•´
  116   1              {
  117   2                      Count = 0 ;
  118   2                      
  119   2                      for (i = 0;i < KEY_COUNT; i ++)
  120   2                      {
  121   3                              PrevState[i] = CurrState[i];//ä¸Šæ¬¡çŠ¶æ€?
  122   3                              CurrState[i] = Key_GetState(i);//æœ¬æ¬¡çŠ¶æ€?
  123   3                              
C251 COMPILER V5.60.0,  Key                                                                24/01/26  14:43:44  PAGE 3   

  124   3                              //ç½®æ ‡å¿—ä½
  125   3                              //Key_Flag |= 0x01;     
  126   3                              //åªæŠŠæœ€ä½ä½ç½®ä¸€ï¼Œè€Œä¸å½±å“å…¶ä»–ä½?
  127   3                              //Key_Flag &= 0xFE;  æˆ–è€? Key_Flag &= ~0x01;
  128   3                              //åªæŠŠæœ€ä½ä½æ¸…é›¶ï¼Œè€Œä¸å½±å“å…¶ä»–ä½?
  129   3                              //ä½¿ç”¨å®å®šä¹‰è½¬æ?xXX,å¢åŠ å¯è¯»æ€?
  130   3                              
  131   3                              if (CurrState[i] == KEY_PRESSED)
  132   3                              {
  133   4                                      Key_Flag[i] |= KEY_HOLD;//HOLD = 1
  134   4                              }
  135   3                              else
  136   3                              {
  137   4                                      Key_Flag[i] &= ~KEY_HOLD;//HOLD = 0
  138   4                              }
  139   3                              
  140   3                              if (CurrState[i] == KEY_PRESSED && PrevState[i] == KEY_UNPRESSED)
  141   3                              {
  142   4                                      Key_Flag[i] |= KEY_DOWN;//DOWM = 1
  143   4                                      //æŒ‰ä¸‹ç¬é—´
  144   4                                      //(ä¸­æ–­ç¨‹åºåªéœ€ç½®ä¸€ï¼Œç”±ä¸»ç¨‹åºç½®é›?
  145   4                              }
  146   3                              
  147   3                              if (CurrState[i] == KEY_UNPRESSED && PrevState[i] == KEY_PRESSED)
  148   3                              {
  149   4                                      Key_Flag[i] |= KEY_UP;//UP = 1
  150   4                                      //æ¾å¼€ç¬é—´
  151   4                              }
  152   3                              
  153   3                              if (S[i] == 0)//çŠ¶æ€ï¼šç©ºé—²
  154   3                              {
  155   4                                      if (CurrState[i] == KEY_PRESSED)//æŒ‰é”®æŒ‰ä¸‹
  156   4                                      {
  157   5                                              Time[i] = KEY_Time_LONG;//è®¾å®šé•¿æŒ‰æ—¶é—´
  158   5                                              S[i] = 1;
  159   5                                      }
  160   4                              }
  161   3                              else if (S[i] == 1)//çŠ¶æ€ï¼šæŒ‰é”®å·²æŒ‰ä¸?
  162   3                              {
  163   4                                      if (CurrState[i] == KEY_UNPRESSED)
  164   4                                      {
  165   5                                              Time[i] = KEY_Time_DOUBLE;//è®¾å®šåŒå‡»æ—¶é—´ï¼ˆåˆ°æ­¤åˆ†æ”¯ï¼Œé•¿æŒ‰æ—¶é—´å·²æ— æ•ˆï¼‰
  166   5                                              S[i] = 2;
  167   5                                      }
  168   4                                      else if (Time[i] == 0)//é•¿æŒ‰æ—¶é—´åˆ°ï¼ˆè¶…æ—¶ï¼?
  169   4                                      {
  170   5                                              Time[i] = KEY_Time_REPEAT;//è®¾å®šé‡å¤æ—¶é—´
  171   5                                              Key_Flag[i] |= KEY_LONG;//LONG=1
  172   5                                              S[i] = 4;
  173   5                                      }
  174   4                              }
  175   3                              else if (S[i] == 2)//çŠ¶æ€ï¼šæŒ‰é”®å·²æ¾å¼€
  176   3                              {
  177   4                                      if (CurrState[i] == KEY_PRESSED)
  178   4                                      {
  179   5                                              Key_Flag[i] |= KEY_DOUBLE;//DOUBLE = 1
  180   5                                              S[i] = 3;
  181   5                                      }
  182   4                                      else if (Time[i] == 0)//åŒå‡»æ—¶é—´åˆ°ï¼ˆè¶…æ—¶ï¼?
  183   4                                      {
  184   5                                              Key_Flag[i] |= KEY_SINGLE;//SINGLE = 1
  185   5                                              S[i] = 0;
  186   5                                      }
  187   4                              }
  188   3                              else if (S[i] == 3)//çŠ¶æ€ï¼šæŒ‰é”®å·²åŒå‡?
  189   3                              {
C251 COMPILER V5.60.0,  Key                                                                24/01/26  14:43:44  PAGE 4   

  190   4                                      if (CurrState[i] == KEY_UNPRESSED)
  191   4                                      {
  192   5                                              S[i] = 0;
  193   5                                      }
  194   4                              }
  195   3                              else if (S[i] == 4)//çŠ¶æ€ï¼šæŒ‰é”®å·²é•¿æŒ?
  196   3                              {
  197   4                                      if (CurrState[i] == KEY_UNPRESSED)
  198   4                                      {
  199   5                                              S[i] = 0;
  200   5                                      }
  201   4                                      else if (Time[i] == 0)
  202   4                                      {
  203   5                                              Time[i] = KEY_Time_REPEAT;
  204   5                                              Key_Flag[i] |= KEY_REPEAT;//REPEAT = 1
  205   5                                              S[i] = 4;
  206   5                                      }
  207   4                              }
  208   3                      }
  209   2                      
  210   2              }
  211   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      1559     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =        29     ------
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =    ------     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

