
C251 COMPILER V5.60.0,  zf_common_fifo                                                     24/01/26  11:15:46  PAGE 1   

C251 COMPILER V5.60.0, COMPILATION OF MODULE zf_common_fifo
OBJECT MODULE PLACED IN .\out_file\zf_common_fifo.obj
COMPILER INVOKED BY: C:\Keil_v5\C251\BIN\C251.EXE ..\..\libraries\zf_common\zf_common_fifo.c LARGE NOALIAS WARNINGLEVEL(
                    -3) OPTIMIZE(0,SIZE) BROWSE INCDIR(..\..\libraries\zf_common;..\..\libraries\zf_components;..\..\libraries\zf_device;..\.
                    -.\libraries\zf_driver;..\user;..\code) DEBUG PRINT(.\out_file\zf_common_fifo.lst) OBJECT(.\out_file\zf_common_fifo.obj) 

stmt  level    source

    1          /********************************************************************************************************
             -*************
    2          * STC32G Opensourec Library 即（STC32G 开源库）是一个基于官方 SDK 接口的第三方开源库
    3          * Copyright (c) 2022 SEEKFREE 逐飞科技
    4          *
    5          * 本文件是STC 开源库的一部分
    6          *
    7          * STC32G 开源库 是免费软件
    8          * 您可以根据自由软件基金会发布的 GPL（GNU General Public License，即 GNU通用公共许可证）的条款
    9          * 即 GPL 的第3版（即 GPL3.0）或（您选择的）任何后来的版本，重新发布和/或修改它
   10          *
   11          * 本开源库的发布是希望它能发挥作用，但并未对其作任何的保证
   12          * 甚至没有隐含的适销性或适合特定用途的保证
   13          * 更多细节请参见 GPL
   14          *
   15          * 您应该在收到本开源库的同时收到一份 GPL 的副本
   16          * 如果没有，请参阅<https://www.gnu.org/licenses/>
   17          *
   18          * 额外注明：
   19          * 本开源库使用 GPL3.0 开源许可证协议 以上许可申明为译文版本
   20          * 许可申明英文版在 libraries/doc 文件夹下的 GPL3_permission_statement.txt 文件中
   21          * 许可证副本在 libraries 文件夹下 即该文件夹下的 LICENSE 文件
   22          * 欢迎各位使用并传播本程序 但修改内容时必须保留逐飞科技的版权声明（即本声明）
   23          *
   24          * 文件名称          
   25          * 公司名称          成都逐飞科技有限公司
   26          * 版本信息          查看 libraries/doc 文件夹内 version 文件 版本说明
   27          * 开发环境          MDK FOR C251
   28          * 适用平台          STC32G
   29          * 店铺链接          https://seekfree.taobao.com/
   30          *
   31          * 修改记录
   32          * 日期              作者           备注
   33          * 2024-08-01        大W            first version
   34          *********************************************************************************************************
             -***********/
   35          
   36          
   37          
   38          #include "zf_common_fifo.h"
   39          #include "zf_common_debug.h"
   40          
   41          #pragma warning disable = 188
   42          
   43          //-------------------------------------------------------------------------------------------------------
             -------------
   44          // 函数简介     FIFO 头指针位移
   45          // 参数说明     *fifo               FIFO 对象指针
   46          // 参数说明     offset              偏移量
   47          // 返回参数     void
   48          // 使用示例     fifo_head_offset(fifo, 1);
   49          // 备注信息     本函数在文件内部调用 用户不用关注 也不可修改
   50          //-------------------------------------------------------------------------------------------------------
             -------------
   51          static void fifo_head_offset (fifo_struct *fifo, uint32 offset)
   52          {
   53   1          fifo->head += offset;

C251 COMPILER V5.60.0,  zf_common_fifo                                                     24/01/26  11:15:46  PAGE 2   
   54   1          
   55   1          while(fifo->max <= fifo->head)                                              // 如果范围超过则减缓冲区
             -大小 直到小于最大缓冲区大小
   56   1          {
   57   2              fifo->head -= fifo->max;
   58   2          }
   59   1      }
   60          
   61          //-------------------------------------------------------------------------------------------------------
             -------------
   62          // 函数简介     FIFO 尾指针位移
   63          // 参数说明     *fifo               FIFO 对象指针
   64          // 参数说明     offset              偏移量
   65          // 返回参数     void
   66          // 使用示例     fifo_end_offset(fifo, 1);
   67          // 备注信息     本函数在文件内部调用 用户不用关注 也不可修改
   68          //-------------------------------------------------------------------------------------------------------
             -------------
   69          static void fifo_end_offset (fifo_struct *fifo, uint32 offset)
   70          {
   71   1          fifo->end += offset;
   72   1          
   73   1          while(fifo->max <= fifo->end)                                               // 如果范围超过则减缓冲区
             -大小 直到小于最大缓冲区大小
   74   1          {
   75   2              fifo->end -= fifo->max;
   76   2          }
   77   1      }
   78          
   79          //-------------------------------------------------------------------------------------------------------
             -------------
   80          // 函数简介     FIFO 重置缓冲器
   81          // 参数说明     *fifo               FIFO 对象指针
   82          // 返回参数     void
   83          // 使用示例     fifo_clear(fifo);
   84          // 备注信息     清空当前 FIFO 对象的内存
   85          //-------------------------------------------------------------------------------------------------------
             -------------
   86          fifo_state_enum fifo_clear (fifo_struct *fifo)
   87          {
   88   1              fifo_state_enum return_state = FIFO_SUCCESS;                                // 操作结果初值
   89   1          zf_assert(NULL != fifo);
   90   1              
   91   1          do
   92   1          {
   93   2              if(FIFO_IDLE != fifo->execution)                                        // 判断是否当前 FIFO 是否
             -空闲
   94   2              {
   95   3                  return_state = FIFO_RESET_UNDO;                                     // 重置操作未完成
   96   3                  break;
   97   3              }
   98   2              fifo->execution |= FIFO_RESET;                                          // 重置操作置位
   99   2              fifo->head      = 0;                                                    // 重置 FIFO 所有数值复位
  100   2              fifo->end       = 0;                                                    // 重置 FIFO 所有数值复位
  101   2              fifo->siz      = fifo->max;                                            // 重置 FIFO 所有数值复位
  102   2              switch(fifo->type)
  103   2              {
  104   3                  case FIFO_DATA_8BIT:    memset(fifo->buffer, 0, fifo->max);     break;
  105   3                  case FIFO_DATA_16BIT:   memset(fifo->buffer, 0, fifo->max * 2); break;
  106   3                  case FIFO_DATA_32BIT:   memset(fifo->buffer, 0, fifo->max * 4); break;
  107   3              }
  108   2              fifo->execution = FIFO_IDLE;                                            // 操作状态复位
  109   2          }while(0);
  110   1          return return_state;
  111   1      }
  112          

C251 COMPILER V5.60.0,  zf_common_fifo                                                     24/01/26  11:15:46  PAGE 3   
  113          //-------------------------------------------------------------------------------------------------------
             -------------
  114          // 函数简介     FIFO 查询当前数据个数
  115          // 参数说明     *fifo               FIFO 对象指针
  116          // 返回参数     uint32              已使用长度
  117          // 使用示例     uint32 len = fifo_used(fifo);
  118          // 备注信息
  119          //-------------------------------------------------------------------------------------------------------
             -------------
  120          uint32 fifo_used (fifo_struct *fifo)
  121          {
  122   1          zf_assert(fifo != NULL);
  123   1          return (fifo->max - fifo->siz);                                            // 返回当前 FIFO 缓冲区中?
             -据个?
  124   1      }
  125          
  126          ////-----------------------------------------------------------------------------------------------------
             ---------------
  127          //// 函数简介     向 FIFO 中写入数据
  128          //// 参数说明     *fifo               FIFO 对象指针
  129          //// 参数说明     dat                 数据
  130          //// 返回参数     fifo_state_enum     操作状态
  131          //// 使用示例     zf_log(fifo_write_element(&fifo, data) == FIFO_SUCCESS, "fifo_write_byte error");
  132          //// 备注信息
  133          ////-----------------------------------------------------------------------------------------------------
             ---------------
  134          //fifo_state_enum fifo_write_element (fifo_struct *fifo, uint32 dat)
  135          //{
  136          //    zf_assert(NULL != fifo);
  137          //    fifo_state_enum return_state = FIFO_SUCCESS;                                // 操作结果初值
  138          
  139          //    do
  140          //    {
  141          //        if((FIFO_RESET | FIFO_WRITE) & fifo->execution)                         // 不在写入与重置状态 ?
             -苊庑慈刖赫与指向错?
  142          //        {
  143          //            return_state = FIFO_WRITE_UNDO;                                     // 写入操作未完成
  144          //            break;
  145          //        }
  146          //        fifo->execution |= FIFO_WRITE;                                          // 写入操作置位
  147          
  148          //        if(1 <= fifo->siz)                                                     // 剩余空间足够装下本次?
             -?
  149          //        {
  150          //            switch(fifo->type)
  151          //            {
  152          //                case FIFO_DATA_8BIT:    ((uint8 *)fifo->buffer)[fifo->head]  = dat;  break;
  153          //                case FIFO_DATA_16BIT:   ((uint16 *)fifo->buffer)[fifo->head] = dat; break;
  154          //                case FIFO_DATA_32BIT:   ((uint32 *)fifo->buffer)[fifo->head] = dat; break;
  155          //            }
  156          //            fifo_head_offset(fifo, 1);                                          // 头指针偏移
  157          //            fifo->siz -= 1;                                                    // 缓冲区剩余长度减小
  158          //        }
  159          //        else
  160          //        {
  161          //            return_state = FIFO_SPACE_NO_ENOUGH;                                // 当前 FIFO 缓冲区满 ?
             -荒茉傩慈胧?返回空间不足
  162          //        }
  163          //        fifo->execution &= ~FIFO_WRITE;                                         // 写入操作复位
  164          //    }while(0);
  165          
  166          //    return return_state;
  167          //}
  168          
  169          //-------------------------------------------------------------------------------------------------------
             -------------

C251 COMPILER V5.60.0,  zf_common_fifo                                                     24/01/26  11:15:46  PAGE 4   
  170          // 函数简介     向 FIFO 中写入数据
  171          // 参数说明     *fifo               FIFO 对象指针
  172          // 参数说明     *dat                数据来源缓冲区指针
  173          // 参数说明     length              需要写入的数据长度
  174          // 返回参数     fifo_state_enum     操作状态
  175          // 使用示例     zf_log(fifo_write_buffer(&fifo, data, 32) == FIFO_SUCCESS, "fifo_write_buffer error");
  176          // 备注信息
  177          //-------------------------------------------------------------------------------------------------------
             -------------
  178          fifo_state_enum fifo_write_buffer (fifo_struct *fifo, void *dat, uint32 length)
  179          {
  180   1          fifo_state_enum return_state = FIFO_SUCCESS;                                // 操作结果初值
  181   1          uint32 temp_length = 0;
  182   1              zf_assert(NULL != fifo);
  183   1              
  184   1          do
  185   1          {
  186   2              if(NULL == dat)
  187   2              {
  188   3                  return_state = FIFO_BUFFER_NULL;                                    // 用户缓冲区异常
  189   3                  break;
  190   3              }
  191   2              if((FIFO_RESET | FIFO_WRITE) & fifo->execution)                         // 不在写入与重置状态 避?
             -庑慈刖赫与指向错?
  192   2              {
  193   3                  return_state = FIFO_WRITE_UNDO;                                     // 写入操作未完成
  194   3                  break;
  195   3              }
  196   2              fifo->execution |= FIFO_WRITE;                                          // 写入操作置位
  197   2      
  198   2              if(length <= fifo->siz)                                                // 剩余空间足够装下本次数?
             -?
  199   2              {
  200   3                  temp_length = fifo->max - fifo->head;                               // 计算头指针距离缓冲区尾
             -还有多少空间
  201   3      
  202   3                  if(length > temp_length)                                            // 距离缓冲区尾长度不足写
             -入数据 环形缓冲区分段操作
  203   3                  {
  204   4                      switch(fifo->type)
  205   4                      {
  206   5                          case FIFO_DATA_8BIT:
  207   5                          {
  208   6                              memcpy(
  209   6                                  &(((uint8 *)fifo->buffer)[fifo->head]),
  210   6                                  dat, temp_length);                                  // 拷贝第一段数据
  211   6                              fifo_head_offset(fifo, temp_length);                    // 头指针偏移
  212   6                              memcpy(
  213   6                                  &(((uint8 *)fifo->buffer)[fifo->head]),
  214   6                                  &(((uint8 *)dat)[temp_length]),
  215   6                                  length - temp_length);                              // 拷贝第二段数据
  216   6                              fifo_head_offset(fifo, length - temp_length);           // 头指针偏移
  217   6                          }break;
  218   5                          case FIFO_DATA_16BIT:
  219   5                          {
  220   6                              memcpy(
  221   6                                  &(((uint16 *)fifo->buffer)[fifo->head]),
  222   6                                  dat, temp_length * 2);                              // 拷贝第一段数据
  223   6                              fifo_head_offset(fifo, temp_length);                    // 头指针偏移
  224   6                              memcpy(
  225   6                                  &(((uint16 *)fifo->buffer)[fifo->head]),
  226   6                                  &(((uint16 *)dat)[temp_length]),
  227   6                                  (length - temp_length) * 2);                        // 拷贝第二段数据
  228   6                              fifo_head_offset(fifo, length - temp_length);           // 头指针偏移
  229   6                          }break;
  230   5                          case FIFO_DATA_32BIT:

C251 COMPILER V5.60.0,  zf_common_fifo                                                     24/01/26  11:15:46  PAGE 5   
  231   5                          {
  232   6                              memcpy(
  233   6                                  &(((uint32 *)fifo->buffer)[fifo->head]),
  234   6                                  dat, temp_length * 4);                              // 拷贝第一段数据
  235   6                              fifo_head_offset(fifo, temp_length);                    // 头指针偏移
  236   6                              memcpy(
  237   6                                  &(((uint32 *)fifo->buffer)[fifo->head]),
  238   6                                  &(((uint32 *)dat)[temp_length]),
  239   6                                  (length - temp_length) * 4);                        // 拷贝第二段数据
  240   6                              fifo_head_offset(fifo, length - temp_length);           // 头指针偏移
  241   6                          }break;
  242   5                      }
  243   4                  }
  244   3                  else
  245   3                  {
  246   4                      switch(fifo->type)
  247   4                      {
  248   5                          case FIFO_DATA_8BIT:
  249   5                          {
  250   6                              memcpy(
  251   6                                  &(((uint8 *)fifo->buffer)[fifo->head]),
  252   6                                  dat, length);                                       // 一次完整写入
  253   6                              fifo_head_offset(fifo, length);                         // 头指针偏移
  254   6                          }break;
  255   5                          case FIFO_DATA_16BIT:
  256   5                          {
  257   6                              memcpy(
  258   6                                  &(((uint16 *)fifo->buffer)[fifo->head]),
  259   6                                  dat, length * 2);                                   // 一次完整写入
  260   6                              fifo_head_offset(fifo, length);                         // 头指针偏移
  261   6                          }break;
  262   5                          case FIFO_DATA_32BIT:
  263   5                          {
  264   6                              memcpy(
  265   6                                  &(((uint32 *)fifo->buffer)[fifo->head]),
  266   6                                  dat, length * 4);                                   // 一次完整写入
  267   6                              fifo_head_offset(fifo, length);                         // 头指针偏移
  268   6                          }break;
  269   5                      }
  270   4                  }
  271   3      
  272   3                  fifo->siz -= length;                                               // 缓冲区剩余长度减小
  273   3              }
  274   2              else
  275   2              {
  276   3                  return_state = FIFO_SPACE_NO_ENOUGH;                                // 当前 FIFO 缓冲区满 不?
             -茉傩慈胧?返回空间不足
  277   3              }
  278   2              fifo->execution &= ~FIFO_WRITE;                                         // 写入操作复位
  279   2          }while(0);
  280   1      
  281   1          return return_state;
  282   1      }
  283          
  284          ////-----------------------------------------------------------------------------------------------------
             ---------------
  285          //// 函数简介     从 FIFO 读取数据
  286          //// 参数说明     *fifo               FIFO 对象指针
  287          //// 参数说明     *dat                目标缓冲区指针
  288          //// 参数说明     flag                是否变更 FIFO 状态 可选择是否清空读取的数据
  289          //// 返回参数     fifo_state_enum     操作状态
  290          //// 使用示例     zf_log(fifo_read_element(&fifo, data, FIFO_READ_ONLY) == FIFO_SUCCESS, "fifo_read_byte 
             -error");
  291          //// 备注信息
  292          ////-----------------------------------------------------------------------------------------------------
             ---------------

C251 COMPILER V5.60.0,  zf_common_fifo                                                     24/01/26  11:15:46  PAGE 6   
  293          //fifo_state_enum fifo_read_element (fifo_struct *fifo, void *dat, fifo_operation_enum flag)
  294          //{
  295          //    zf_assert(NULL != fifo);
  296          //    fifo_state_enum return_state = FIFO_SUCCESS;                                // 操作结果初值
  297          
  298          //    do
  299          //    {
  300          //        if(NULL == dat)
  301          //        {
  302          //            return_state = FIFO_BUFFER_NULL;                                    // 用户缓冲区异常
  303          //        }
  304          //        else
  305          //        {
  306          //            if((FIFO_RESET | FIFO_CLEAR) & fifo->execution)                     // 判断是否当前 FIFO 是
             -否在执行清空或重置操作
  307          //            {
  308          //                return_state = FIFO_READ_UNDO;                                  // 读取操作未完成
  309          //                break;
  310          //            }
  311          
  312          //            if(1 > fifo_used(fifo))
  313          //            {
  314          //                return_state = FIFO_DATA_NO_ENOUGH;                             // 缓冲区没有数据 返回?
             -据长度不?
  315          //                break;                                                          // 直接退出操作
  316          //            }
  317          
  318          //            fifo->execution |= FIFO_READ;                                       // 读操作置位
  319          //            switch(fifo->type)
  320          //            {
  321          //                case FIFO_DATA_8BIT:    *((uint8 *)dat) = ((uint8 *)fifo->buffer)[fifo->end];   break;
  322          //                case FIFO_DATA_16BIT:   *((uint16 *)dat) = ((uint16 *)fifo->buffer)[fifo->end]; break;
  323          //                case FIFO_DATA_32BIT:   *((uint32 *)dat) = ((uint32 *)fifo->buffer)[fifo->end]; break;
  324          //            }
  325          //            fifo->execution &= ~FIFO_READ;                                      // 读操作复位
  326          //        }
  327          
  328          //        if(FIFO_READ_AND_CLEAN == flag)                                         // 如果选择读取并更改 F
             -IFO 状态
  329          //        {
  330          //            if((FIFO_RESET | FIFO_CLEAR | FIFO_READ) == fifo->execution)        // 不在 重置 清空 读取 
             -状态 避免异常
  331          //            {
  332          //                return_state = FIFO_CLEAR_UNDO;                                 // 清空操作未完成
  333          //                break;
  334          //            }
  335          //            fifo->execution |= FIFO_CLEAR;                                      // 清空作置位
  336          //            fifo_end_offset(fifo, 1);                                           // 移动 FIFO 头指针
  337          //            fifo->siz += 1;                                                    // 释放对应长度空间
  338          //            fifo->execution &= ~FIFO_CLEAR;                                     // 清空作复位
  339          //        }
  340          //    }while(0);
  341          
  342          //    return return_state;
  343          //}
  344          
  345          //-------------------------------------------------------------------------------------------------------
             -------------
  346          // 函数简介     从 FIFO 读取数据
  347          // 参数说明     *fifo               FIFO 对象指针
  348          // 参数说明     *dat                目标缓冲区指针
  349          // 参数说明     *length             读取的数据长度 如果没有这么多数据这里会被修改
  350          // 参数说明     flag                是否变更 FIFO 状态 可选择是否清空读取的数据
  351          // 返回参数     fifo_state_enum     操作状态
  352          // 使用示例     zf_log(fifo_read_buffer(&fifo, data, &length, FIFO_READ_ONLY) == FIFO_SUCCESS, "fifo_read
             -_buffer error");

C251 COMPILER V5.60.0,  zf_common_fifo                                                     24/01/26  11:15:46  PAGE 7   
  353          // 备注信息
  354          //-------------------------------------------------------------------------------------------------------
             -------------
  355          fifo_state_enum fifo_read_buffer (fifo_struct *fifo, void *dat, uint32 *length, fifo_operation_enum flag)
  356          {
  357   1          fifo_state_enum return_state = FIFO_SUCCESS;                                // 操作结果初值
  358   1          uint32 temp_length = 0;
  359   1          uint32 fifo_data_length = 0;
  360   1              
  361   1          zf_assert(NULL != fifo);
  362   1          zf_assert(NULL != length);
  363   1              
  364   1          do
  365   1          {
  366   2              if(NULL == dat)
  367   2              {
  368   3                  return_state = FIFO_BUFFER_NULL;
  369   3              }
  370   2              else
  371   2              {
  372   3                  if((FIFO_RESET | FIFO_CLEAR) & fifo->execution)                     // 判断是否当前 FIFO 是否
             -在执行清空或重置操作
  373   3                  {
  374   4                      *length = fifo_data_length;                                     // 纠正读取的长度
  375   4                      return_state = FIFO_READ_UNDO;                                  // 读取操作未完成
  376   4                      break;
  377   4                  }
  378   3      
  379   3                  fifo_data_length = fifo_used(fifo);                                 // 获取当前数据有多少
  380   3                  if(*length > fifo_data_length)                                      // 判断长度是否足够
  381   3                  {
  382   4                      *length = fifo_data_length;                                     // 纠正读取的长度
  383   4                      return_state = FIFO_DATA_NO_ENOUGH;                             // 标志数据不够
  384   4                      if(0 == fifo_data_length)                                       // 如果没有数据 就直接退?
             -?
  385   4                      {
  386   5                          fifo->execution &= ~FIFO_READ;                              // 读操作复位
  387   5                          break;
  388   5                      }
  389   4                  }
  390   3      
  391   3                  fifo->execution |= FIFO_READ;                                       // 读操作置位
  392   3                  temp_length = fifo->max - fifo->end;                                // 计算尾指针距离缓冲区尾
             -还有多少空间
  393   3                  if(*length <= temp_length)                                          // 足够一次性读取完毕
  394   3                  {
  395   4                      switch(fifo->type)
  396   4                      {
  397   5                          case FIFO_DATA_8BIT:    memcpy(dat, &(((uint8 *)fifo->buffer)[fifo->end]), *length); 
             -       break;
  398   5                          case FIFO_DATA_16BIT:   memcpy(dat, &(((uint16 *)fifo->buffer)[fifo->end]), *length *
             - 2);   break;
  399   5                          case FIFO_DATA_32BIT:   memcpy(dat, &(((uint32 *)fifo->buffer)[fifo->end]), *length *
             - 4);   break;
  400   5                      }
  401   4                  }
  402   3                  else
  403   3                  {
  404   4                      switch(fifo->type)
  405   4                      {
  406   5                          case FIFO_DATA_8BIT:
  407   5                          {
  408   6                              memcpy(dat, &(((uint8 *)fifo->buffer)[fifo->end]), temp_length);
  409   6                              memcpy(&(((uint8 *)dat)[temp_length]), fifo->buffer, *length - temp_length);
  410   6                          }break;
  411   5                          case FIFO_DATA_16BIT:

C251 COMPILER V5.60.0,  zf_common_fifo                                                     24/01/26  11:15:46  PAGE 8   
  412   5                          {
  413   6                              memcpy(dat, &(((uint16 *)fifo->buffer)[fifo->end]), temp_length * 2);
  414   6                              memcpy(&(((uint16 *)dat)[temp_length]), fifo->buffer, (*length - temp_length) * 2
             -);
  415   6                          }break;
  416   5                          case FIFO_DATA_32BIT:
  417   5                          {
  418   6                              memcpy(dat, &(((uint32 *)fifo->buffer)[fifo->end]), temp_length * 4);
  419   6                              memcpy(&(((uint32 *)dat)[temp_length]), fifo->buffer, (*length - temp_length) * 4
             -);
  420   6                          }break;
  421   5                      }
  422   4                  }
  423   3                  fifo->execution &= ~FIFO_READ;                                      // 读操作复位
  424   3              }
  425   2      
  426   2              if(FIFO_READ_AND_CLEAN == flag)                                         // 如果选择读取并更改 FIF
             -O 状态
  427   2              {
  428   3                  if((FIFO_RESET | FIFO_CLEAR | FIFO_READ) == fifo->execution)        // 不在 重置 清空 读取 状
             -态 避免异常
  429   3                  {
  430   4                      return_state = FIFO_CLEAR_UNDO;                                 // 清空操作未完成
  431   4                      break;
  432   4                  }
  433   3                  fifo->execution |= FIFO_CLEAR;                                      // 清空作置位
  434   3                  fifo_end_offset(fifo, *length);                                     // 移动 FIFO 头指针
  435   3                  fifo->siz += *length;                                              // 释放对应长度空间
  436   3                  fifo->execution &= ~FIFO_CLEAR;                                     // 清空作复位
  437   3              }
  438   2          }while(0);
  439   1      
  440   1          return return_state;
  441   1      }
  442          
  443          ////-----------------------------------------------------------------------------------------------------
             ---------------
  444          //// 函数简介     从 FIFO 尾部读取指定长度 buffer
  445          //// 参数说明     *fifo               FIFO 对象指针
  446          //// 参数说明     *dat                目标缓冲区指针
  447          //// 参数说明     *length             读取的数据长度 如果没有这么多数据这里会被修改
  448          //// 参数说明     flag                是否变更 FIFO 状态 可选择是否清空读取的数据
  449          //// 返回参数     fifo_state_enum     操作状态
  450          //// 使用示例     zf_log(fifo_read_tail_buffer(&fifo, data, &length, FIFO_READ_ONLY) == FIFO_SUCCESS, "fi
             -fo_read_buffer error");
  451          //// 备注信息     如果使用 FIFO_READ_AND_CLEAN 操作 将会丢弃所有数据并清空整个 FIFO
  452          ////              如果使用 FIFO_READ_AND_CLEAN 操作 将会丢弃所有数据并清空整个 FIFO
  453          ////              如果使用 FIFO_READ_AND_CLEAN 操作 将会丢弃所有数据并清空整个 FIFO
  454          ////-----------------------------------------------------------------------------------------------------
             ---------------
  455          //fifo_state_enum fifo_read_tail_buffer (fifo_struct *fifo, void *dat, uint32 *length, fifo_operation_enu
             -m flag)
  456          //{
  457          //    zf_assert(NULL != fifo);
  458          //    zf_assert(NULL != length);
  459          //    fifo_state_enum return_state = FIFO_SUCCESS;                                // 操作结果初值
  460          //    uint32 temp_length = 0;
  461          //    uint32 fifo_data_length = 0;
  462          
  463          //    do
  464          //    {
  465          //        if(NULL == dat)
  466          //        {
  467          //            return_state = FIFO_BUFFER_NULL;
  468          //        }
  469          //        else

C251 COMPILER V5.60.0,  zf_common_fifo                                                     24/01/26  11:15:46  PAGE 9   
  470          //        {
  471          //            if((FIFO_RESET | FIFO_CLEAR | FIFO_WRITE) & fifo->execution)        // 判断是否当前 FIFO 是
             -否在执行清空或重置操作
  472          //            {
  473          //                *length = fifo_data_length;                                     // 纠正读取的长度
  474          //                return_state = FIFO_READ_UNDO;                                  // 读取操作未完成
  475          //                break;
  476          //            }
  477          
  478          //            fifo_data_length = fifo_used(fifo);                                 // 获取当前数据有多少
  479          //            if(*length > fifo_data_length)                                      // 判断长度是否足够
  480          //            {
  481          //                *length = fifo_data_length;                                     // 纠正读取的长度
  482          //                return_state = FIFO_DATA_NO_ENOUGH;                             // 标志数据不够
  483          //                if(0 == fifo_data_length)                                       // 如果没有数据 就直接?
             -顺?
  484          //                {
  485          //                    fifo->execution &= ~FIFO_READ;                              // 读操作复位
  486          //                    break;
  487          //                }
  488          //            }
  489          
  490          //            fifo->execution |= FIFO_READ;                                       // 读操作置位
  491          //            if((fifo->head > fifo->end) || (fifo->head >= *length))
  492          //            {
  493          //                switch(fifo->type)
  494          //                {
  495          //                    case FIFO_DATA_8BIT:    memcpy(dat, &(((uint8 *)fifo->buffer)[fifo->head - *length]
             -), *length);     break;
  496          //                    case FIFO_DATA_16BIT:   memcpy(dat, &(((uint16 *)fifo->buffer)[fifo->head - *length
             -]), *length * 2);break;
  497          //                    case FIFO_DATA_32BIT:   memcpy(dat, &(((uint32 *)fifo->buffer)[fifo->head - *length
             -]), *length * 4);break;
  498          //                }
  499          //            }
  500          //            else
  501          //            {
  502          //                temp_length = *length - fifo->head;                             // 计算尾指针距离缓冲区
             -尾还有多少空间
  503          //                switch(fifo->type)
  504          //                {
  505          //                    case FIFO_DATA_8BIT:
  506          //                    {
  507          //                        memcpy(dat, &(((uint8 *)fifo->buffer)[fifo->max - temp_length]), temp_length);
  508          //                        memcpy(&(((uint8 *)dat)[temp_length]), &(((uint8 *)fifo->buffer)[fifo->head - *
             -length]), (*length - temp_length));
  509          //                    }break;
  510          //                    case FIFO_DATA_16BIT:
  511          //                    {
  512          //                        memcpy(dat, &(((uint16 *)fifo->buffer)[fifo->max - temp_length]), temp_length *
             - 2);
  513          //                        memcpy(&(((uint16 *)dat)[temp_length]), &(((uint16 *)fifo->buffer)[fifo->head -
             - *length]), (*length - temp_length) * 2);
  514          //                    }break;
  515          //                    case FIFO_DATA_32BIT:
  516          //                    {
  517          //                        memcpy(dat, &(((uint32 *)fifo->buffer)[fifo->max - temp_length]), temp_length *
             - 4);
  518          //                        memcpy(&(((uint32 *)dat)[temp_length]), &(((uint32 *)fifo->buffer)[fifo->head -
             - *length]), (*length - temp_length) * 4);
  519          //                    }break;
  520          //                }
  521          //            }
  522          //            fifo->execution &= ~FIFO_READ;                                      // 读操作复位
  523          //        }
  524          

C251 COMPILER V5.60.0,  zf_common_fifo                                                     24/01/26  11:15:46  PAGE 10  
  525          //        if(FIFO_READ_AND_CLEAN == flag)                                         // 如果选择读取并更改 F
             -IFO 状态
  526          //        {
  527          //            if((FIFO_RESET | FIFO_CLEAR | FIFO_READ) == fifo->execution)        // 不在 重置 清空 读取 
             -状态 避免异常
  528          //            {
  529          //                return_state = FIFO_CLEAR_UNDO;                                 // 清空操作未完成
  530          //                break;
  531          //            }
  532          //            fifo_clear(fifo);
  533          //        }
  534          //    }while(0);
  535          
  536          //    return return_state;
  537          //}
  538          
  539          //-------------------------------------------------------------------------------------------------------
             -------------
  540          // 函数简介     FIFO 初始化 挂载对应缓冲区
  541          // 参数说明     *fifo               FIFO 对象指针
  542          // 参数说明     type                FIFO 数据位数
  543          // 参数说明     *buffer_addr        要挂载的缓冲区
  544          // 参数说明     siz                缓冲区大小
  545          // 返回参数     fifo_state_enum     操作状态
  546          // 使用示例     fifo_init(&user_fifo, user_buffer, 64);
  547          // 备注信息
  548          //-------------------------------------------------------------------------------------------------------
             -------------
  549          fifo_state_enum fifo_init (fifo_struct *fifo, fifo_data_type_enum type, void *buffer_addr, uint32 siz)
  550          {
  551   1          zf_assert(NULL != fifo);
  552   1          do
  553   1          {
  554   2              fifo->buffer    = buffer_addr;
  555   2              fifo->execution = FIFO_IDLE;
  556   2              fifo->type      = type;
  557   2              fifo->head      = 0;
  558   2              fifo->end       = 0;
  559   2              fifo->siz      = siz;
  560   2              fifo->max       = siz;
  561   2          }while(0);
  562   1          return FIFO_SUCCESS;
  563   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      3931     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =        82     ------
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =        43     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

