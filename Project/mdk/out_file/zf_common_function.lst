
C251 COMPILER V5.60.0,  zf_common_function                                                 24/01/26  11:15:46  PAGE 1   

C251 COMPILER V5.60.0, COMPILATION OF MODULE zf_common_function
OBJECT MODULE PLACED IN .\out_file\zf_common_function.obj
COMPILER INVOKED BY: C:\Keil_v5\C251\BIN\C251.EXE ..\..\libraries\zf_common\zf_common_function.c LARGE NOALIAS WARNINGLE
                    -VEL(3) OPTIMIZE(0,SIZE) BROWSE INCDIR(..\..\libraries\zf_common;..\..\libraries\zf_components;..\..\libraries\zf_device;
                    -..\..\libraries\zf_driver;..\user;..\code) DEBUG PRINT(.\out_file\zf_common_function.lst) OBJECT(.\out_file\zf_common_fu
                    -nction.obj) 

stmt  level    source

    1          /********************************************************************************************************
             -*************
    2          * STC32G Opensourec Library 即（STC32G 开源库）是一个基于官方 SDK 接口的第三方开源库
    3          * Copyright (c) 2022 SEEKFREE 逐飞科技
    4          *
    5          * 本文件是STC 开源库的一部分
    6          *
    7          * STC32G 开源库 是免费软件
    8          * 您可以根据自由软件基金会发布的 GPL（GNU General Public License，即 GNU通用公共许可证）的条款
    9          * 即 GPL 的第3版（即 GPL3.0）或（您选择的）任何后来的版本，重新发布和/或修改它
   10          *
   11          * 本开源库的发布是希望它能发挥作用，但并未对其作任何的保证
   12          * 甚至没有隐含的适销性或适合特定用途的保证
   13          * 更多细节请参见 GPL
   14          *
   15          * 您应该在收到本开源库的同时收到一份 GPL 的副本
   16          * 如果没有，请参阅<https://www.gnu.org/licenses/>
   17          *
   18          * 额外注明：
   19          * 本开源库使用 GPL3.0 开源许可证协议 以上许可申明为译文版本
   20          * 许可申明英文版在 libraries/doc 文件夹下的 GPL3_permission_statement.txt 文件中
   21          * 许可证副本在 libraries 文件夹下 即该文件夹下的 LICENSE 文件
   22          * 欢迎各位使用并传播本程序 但修改内容时必须保留逐飞科技的版权声明（即本声明）
   23          *
   24          * 文件名称          
   25          * 公司名称          成都逐飞科技有限公司
   26          * 版本信息          查看 libraries/doc 文件夹内 version 文件 版本说明
   27          * 开发环境          MDK FOR C251
   28          * 适用平台          STC32G
   29          * 店铺链接          https://seekfree.taobao.com/
   30          *
   31          * 修改记录
   32          * 日期              作者           备注
   33          * 2024-08-01        大W            first version
   34          *********************************************************************************************************
             -***********/
   35          
   36          #include "zf_common_debug.h"
   37          #include "zf_common_function.h"
   38          #include <stdarg.h>  // 包含标准可变参数宏的头文件
   39          #include <stdio.h>   // 包含标准输入输出的头文件
   40          
   41          //-------------------------------------------------------------------------------------------------------
             -------------
   42          // 函数简介     获取整型数的最大公约数 九章算术之更相减损术
   43          // 参数说明     num1            数字1
   44          // 参数说明     num2            数字2
   45          // 返回参数     uint32          最大公约数
   46          // 使用示例     return func_get_greatest_common_divisor(144, 36);               // 获取 144 与 36 的最大?
             -约?
   47          // 备注信息     
   48          //-------------------------------------------------------------------------------------------------------
             -------------
   49          uint32 func_get_greatest_common_divisor (uint32 num1, uint32 num2)
   50          {
   51   1          while(num1 != num2)

C251 COMPILER V5.60.0,  zf_common_function                                                 24/01/26  11:15:46  PAGE 2   
   52   1          {
   53   2              if(num1 > num2)
   54   2              {
   55   3                  num1 = num1 - num2;
   56   3              }
   57   2              if(num1 < num2)
   58   2              {
   59   3                  num2 = num2 - num1;
   60   3              }
   61   2          }
   62   1          return num1;
   63   1      }
   64          
   65          //-------------------------------------------------------------------------------------------------------
             -------------
   66          // 函数简介     软件延时
   67          // 参数说明     t               延时时间
   68          // 返回参数     void
   69          // 使用示例     func_soft_delay(100);
   70          // 备注信息     
   71          //-------------------------------------------------------------------------------------------------------
             -------------
   72          void func_soft_delay (volatile long t)
   73          {
   74   1          while(t --);
   75   1      }
   76          
   77          //-------------------------------------------------------------------------------------------------------
             -------------
   78          // 函数简介     字符串转整形数字 数据范围是 [-32768,32767]
   79          // 参数说明     *str            传入字符串 可带符号
   80          // 返回参数     int32           转换后的数据          
   81          // 使用示例     int32 dat = func_str_to_int("-100");
   82          // 备注信息     
   83          //-------------------------------------------------------------------------------------------------------
             -------------
   84          int32 func_str_to_int (char *str)
   85          {
   86   1          uint8 sign = 0;                                                             // 标记符号 0-正数 1-负数
   87   1          int32 temp = 0;                                                             // 临时计算变量
   88   1              zf_assert(str != NULL);
   89   1              do
   90   1          {
   91   2              if(NULL == str)
   92   2              {
   93   3                  break;
   94   3              }
   95   2      
   96   2              if('-' == *str)                                                         // 如果第一个字符是负号
   97   2              {
   98   3                  sign = 1;                                                           // 标记负数
   99   3                  str ++;
  100   3              }
  101   2              else if('+' == *str)                                                    // 如果第一个字符是正号
  102   2              {
  103   3                  str ++;
  104   3              }
  105   2      
  106   2              while(('0' <= *str) && ('9' >= *str))                                   // 确定这是个数字
  107   2              {
  108   3                  temp = temp * 10 + ((uint8)(*str) - 0x30);                          // 计算数值
  109   3                  str ++;
  110   3              }
  111   2      
  112   2              if(sign)
  113   2              {

C251 COMPILER V5.60.0,  zf_common_function                                                 24/01/26  11:15:46  PAGE 3   
  114   3                  temp = -temp;
  115   3              }
  116   2          }while(0);
  117   1          return temp;
  118   1      }
  119          
  120          //-------------------------------------------------------------------------------------------------------
             -------------
  121          // 函数简介     整形数字转字符串 数据范围是 [-32768,32767]
  122          // 参数说明     *str            字符串指针
  123          // 参数说明     number          传入的数据
  124          // 返回参数     void
  125          // 使用示例     func_int_to_str(data_buffer, -300);
  126          // 备注信息     
  127          //-------------------------------------------------------------------------------------------------------
             -------------
  128          void func_int_to_str (char *str, int32 number)
  129          {
  130   1          uint8 data_temp[16];                                                        // 缓冲区
  131   1          uint8 temp_bit = 0;                                                              // 数字位数
  132   1          int32 number_temp = 0;
  133   1          zf_assert(str != NULL);
  134   1          do
  135   1          {
  136   2              if(NULL == str)
  137   2              {
  138   3                  break;
  139   3              }
  140   2      
  141   2              if(0 > number)                                                          // 负数
  142   2              {
  143   3                  *str ++ = '-';
  144   3                  number = -number;
  145   3              }
  146   2              else if(0 == number)                                                    // 或者这是个 0
  147   2              {
  148   3                  *str = '0';
  149   3                  break;
  150   3              }
  151   2      
  152   2              while(0 != number)                                                      // 循环直到数值归零
  153   2              {
  154   3                  number_temp = number % 10;
  155   3                  data_temp[temp_bit ++] = func_abs(number_temp);                          // 倒序将数值提取出?
             -?
  156   3                  number /= 10;                                                       // 削减被提取的个位数
  157   3              }
  158   2              while(0 != temp_bit)                                                         // 提取的数字个数递?
             -醮?
  159   2              {
  160   3                  *str ++ = (data_temp[temp_bit - 1] + 0x30);                              // 将数字从倒序数组?
             -械剐蛉〕?变成正序放入字符串
  161   3                  temp_bit --;
  162   3              }
  163   2          }while(0);
  164   1      }
  165          
  166          //-------------------------------------------------------------------------------------------------------
             -------------
  167          // 函数简介     字符串转整形数字 数据范围是 [0,65535]
  168          // 参数说明     *str            传入字符串 无符号
  169          // 返回参数     uint32          转换后的数据          
  170          // 使用示例     uint32 dat = func_str_to_uint("100");
  171          // 备注信息     
  172          //-------------------------------------------------------------------------------------------------------
             -------------

C251 COMPILER V5.60.0,  zf_common_function                                                 24/01/26  11:15:46  PAGE 4   
  173          uint32 func_str_to_uint (char *str)
  174          {
  175   1              uint32 temp = 0;                                                            // 临时计算变量
  176   1          zf_assert(str != NULL);
  177   1      
  178   1          do
  179   1          {
  180   2              if(NULL == str)
  181   2              {
  182   3                  break;
  183   3              }
  184   2      
  185   2              while(('0' <= *str) && ('9' >= *str))                                  // 确定这是个数字
  186   2              {
  187   3                  temp = temp * 10 + ((uint8)(*str) - 0x30);                         // 计算数值
  188   3                  str ++;
  189   3              }
  190   2          }while(0);
  191   1      
  192   1          return temp;
  193   1      }
  194          
  195          //-------------------------------------------------------------------------------------------------------
             -------------
  196          // 函数简介     整形数字转字符串 数据范围是 [0,65535]
  197          // 参数说明     *str            字符串指针
  198          // 参数说明     number          传入的数据
  199          // 返回参数     void
  200          // 使用示例     func_uint_to_str(data_buffer, 300);
  201          // 备注信息     
  202          //-------------------------------------------------------------------------------------------------------
             -------------
  203          void func_uint_to_str (char *str, uint32 number)
  204          {
  205   1          int8 data_temp[16];                                                         // 缓冲区
  206   1          uint8 temp_bit = 0;                                                              // 数字位数
  207   1          
  208   1              zf_assert(str != NULL);
  209   1          
  210   1              do
  211   1          {
  212   2              if(NULL == str)
  213   2              {
  214   3                  break;
  215   3              }
  216   2      
  217   2              if(0 == number)                                                         // 这是个 0
  218   2              {
  219   3                  *str = '0';
  220   3                  break;
  221   3              }
  222   2      
  223   2              while(0 != number)                                                      // 循环直到数值归零
  224   2              {
  225   3                  data_temp[temp_bit ++] = (number % 10);                                  // 倒序将数值提取出?
             -?
  226   3                  number /= 10;                                                       // 削减被提取的个位数
  227   3              }
  228   2              while(0 != temp_bit)                                                         // 提取的数字个数递?
             -醮?
  229   2              {
  230   3                  *str ++ = (data_temp[temp_bit - 1] + 0x30);                              // 将数字从倒序数组?
             -械剐蛉〕?变成正序放入字符串
  231   3                  temp_bit --;
  232   3              }
  233   2          }while(0);

C251 COMPILER V5.60.0,  zf_common_function                                                 24/01/26  11:15:46  PAGE 5   
  234   1      }
  235          
  236          //-------------------------------------------------------------------------------------------------------
             -------------
  237          // 函数简介     字符串转浮点数 有效累计精度为小数点后六位
  238          // 参数说明     *str            传入字符串 可带符号
  239          // 返回参数     float           转换后的数据          
  240          // 使用示例     float dat = func_str_to_float("-100.2");
  241          // 备注信息     
  242          //-------------------------------------------------------------------------------------------------------
             -------------
  243          float func_str_to_float (char *str)
  244          {
  245   1          uint8 sign = 0;                                                             // 标记符号 0-正数 1-负数
  246   1          float temp = 0.0;                                                           // 临时计算变量 整数部分
  247   1          float temp_point = 0.0;                                                     // 临时计算变量 小数部分
  248   1          float point_bit = 1;                                                        // 小数累计除数
  249   1          
  250   1              zf_assert(str != NULL);
  251   1          
  252   1              do
  253   1          {
  254   2              if(NULL == str)
  255   2              {
  256   3                  break;
  257   3              }
  258   2      
  259   2              if('-' == *str)                                                         // 负数
  260   2              {
  261   3                  sign = 1;                                                           // 标记负数
  262   3                  str ++;
  263   3              }
  264   2              else if('+' == *str)                                                    // 如果第一个字符是正号
  265   2              {
  266   3                  str ++;
  267   3              }
  268   2      
  269   2              // 提取整数部分
  270   2              while(('0' <= *str) && ('9' >= *str))                                   // 确定这是个数字
  271   2              {
  272   3                  temp = temp * 10 + ((uint8)(*str) - 0x30);                          // 将数值提取出来
  273   3                  str ++;
  274   3              }
  275   2              if('.' == *str)
  276   2              {
  277   3                  str ++;
  278   3                  while(('0' <= *str) && ('9' >= *str) && point_bit < 1000000.0)      // 确认这是个数字 并且精?
             -瓤刂苹姑坏搅?
  279   3                  {
  280   4                      temp_point = temp_point * 10 + ((uint8)(*str) - 0x30);          // 提取小数部分数值
  281   4                      point_bit *= 10;                                                // 计算这部分小数的除数
  282   4                      str ++;
  283   4                  }
  284   3                  temp_point /= point_bit;                                            // 计算小数
  285   3              }
  286   2              temp += temp_point;                                                     // 将数值拼合
  287   2      
  288   2              if(sign)
  289   2              {
  290   3                  temp = -temp;
  291   3              }
  292   2          }while(0);
  293   1          return temp;
  294   1      }
  295          
  296          //-------------------------------------------------------------------------------------------------------

C251 COMPILER V5.60.0,  zf_common_function                                                 24/01/26  11:15:46  PAGE 6   
             -------------
  297          // 函数简介     浮点数字转字符串
  298          // 参数说明     *str            字符串指针
  299          // 参数说明     number          传入的数据
  300          // 参数说明     point_bit       小数点精度
  301          // 返回参数     void
  302          // 使用示例     func_float_to_str(data_buffer, 3.1415, 2);                      // 结果输出 data_buffer =
             - "3.14"
  303          // 备注信息     
  304          //-------------------------------------------------------------------------------------------------------
             -------------
  305          void func_float_to_str (char *str, float number, uint8 point_bit)
  306          {
  307   1          int data_int = 0;                                                           // 整数部分
  308   1          int data_float = 0.0;                                                       // 小数部分
  309   1          int data_temp[8];                                                           // 整数字符缓冲
  310   1          int data_temp_point[6];                                                     // 小数字符缓冲
  311   1          uint8 temp_bit = point_bit;                                                      // 转换精度位数
  312   1          
  313   1              zf_assert(str != NULL);
  314   1          
  315   1              do
  316   1          {
  317   2              if(NULL == str)
  318   2              {
  319   3                  break;
  320   3              }
  321   2      
  322   2              // 提取整数部分
  323   2              data_int = (int)number;                                                 // 直接强制转换为 int
  324   2              if(0 > number)                                                          // 判断源数据是正数还是负
             -数
  325   2              {
  326   3                  *str ++ = '-';
  327   3              }
  328   2              else if(0.0 == number)                                                  // 如果是个 0
  329   2              {
  330   3                  *str ++ = '0';
  331   3                  *str ++ = '.';
  332   3                  *str = '0';
  333   3                  break;
  334   3              }
  335   2      
  336   2              // 提取小数部分
  337   2              number = number - data_int;                                             // 减去整数部分即可
  338   2              while(temp_bit --)
  339   2              {
  340   3                  number = number * 10;                                               // 将需要的小数位数提取到
             -整数部分
  341   3              }
  342   2              data_float = (int)number;                                               // 获取这部分数值
  343   2      
  344   2              // 整数部分转为字符串
  345   2              temp_bit = 0;
  346   2              do
  347   2              {
  348   3                  data_temp[temp_bit ++] = data_int % 10;                                  // 将整数部分倒序写?
             -胱址缓冲?
  349   3                  data_int /= 10;
  350   3              }while(0 != data_int);
  351   2              while(0 != temp_bit)
  352   2              {
  353   3                  *str ++ = (func_abs(data_temp[temp_bit - 1]) + 0x30);                    // 再倒序将倒序的数?
             -敌慈胱址?得到正序数值
  354   3                  temp_bit --;
  355   3              }

C251 COMPILER V5.60.0,  zf_common_function                                                 24/01/26  11:15:46  PAGE 7   
  356   2      
  357   2              // 小数部分转为字符串
  358   2              if(point_bit != 0)
  359   2              {
  360   3                  temp_bit = 0;
  361   3                  *str ++ = '.';
  362   3                  if(0 == data_float)
  363   3                  {
  364   4                      *str = '0';
  365   4                  }
  366   3                  else
  367   3                  {
  368   4                      while(0 != point_bit)                                           // 判断有效位数
  369   4                      {
  370   5                          data_temp_point[temp_bit ++] = data_float % 10;                  // 倒序写入字符缓冲?
             -?
  371   5                          data_float /= 10;
  372   5                          point_bit --;                                                
  373   5                      }
  374   4                      while(0 != temp_bit)
  375   4                      {
  376   5                          *str ++ = (func_abs(data_temp_point[temp_bit - 1]) + 0x30);      // 再倒序将倒序的数?
             -敌慈胱址?得到正序数值
  377   5                          temp_bit --;
  378   5                      }
  379   4                  }
  380   3              }
  381   2          }while(0);
  382   1      }
  383          
  384          //-------------------------------------------------------------------------------------------------------
             -------------
  385          // 函数简介     字符串转浮点数 有效累计精度为小数点后九位
  386          // 参数说明     str             传入字符串 可带符号
  387          // 返回参数     double          转换后的数据          
  388          // 使用示例     double dat = func_str_to_double("-100.2");
  389          // 备注信息     
  390          //-------------------------------------------------------------------------------------------------------
             -------------
  391          double func_str_to_double (char *str)
  392          {
  393   1          uint8 sign = 0;                                                             // 标记符号 0-正数 1-负数
  394   1          double temp = 0.0;                                                          // 临时计算变量 整数部分
  395   1          double temp_point = 0.0;                                                    // 临时计算变量 小数部分
  396   1          double point_bit = 1;                                                       // 小数累计除数
  397   1          
  398   1              zf_assert(str != NULL);
  399   1          
  400   1              do
  401   1          {
  402   2              if(NULL == str)
  403   2              {
  404   3                  break;
  405   3              }
  406   2      
  407   2              if('-' == *str)                                                         // 负数
  408   2              {
  409   3                  sign = 1;                                                           // 标记负数
  410   3                  str ++;
  411   3              }
  412   2              else if('+' == *str)                                                    // 如果第一个字符是正号
  413   2              {
  414   3                  str ++;
  415   3              }
  416   2      
  417   2              // 提取整数部分

C251 COMPILER V5.60.0,  zf_common_function                                                 24/01/26  11:15:46  PAGE 8   
  418   2              while(('0' <= *str) && ('9' >= *str))                                   // 确定这是个数字
  419   2              {
  420   3                  temp = temp * 10 + ((uint8)(*str) - 0x30);                          // 将数值提取出来
  421   3                  str ++;
  422   3              }
  423   2              if('.' == *str)
  424   2              {
  425   3                  str ++;
  426   3                  while(('0' <= *str) && ('9' >= *str) && point_bit < 1000000000.0)   // 确认这是个数字 并且精?
             -瓤刂苹姑坏骄盼?
  427   3                  {
  428   4                      temp_point = temp_point * 10 + ((uint8)(*str) - 0x30);          // 提取小数部分数值
  429   4                      point_bit *= 10;                                                // 计算这部分小数的除数
  430   4                      str ++;
  431   4                  }
  432   3                  temp_point /= point_bit;                                            // 计算小数
  433   3              }
  434   2              temp += temp_point;                                                     // 将数值拼合
  435   2      
  436   2              if(sign)
  437   2              {
  438   3                  temp = -temp;
  439   3              }
  440   2          }while(0);
  441   1          return temp;
  442   1      
  443   1      }
  444          
  445          //-------------------------------------------------------------------------------------------------------
             -------------
  446          // 函数简介     浮点数字转字符串
  447          // 参数说明     *str            字符串指针
  448          // 参数说明     number          传入的数据
  449          // 参数说明     point_bit       小数点精度
  450          // 返回参数     void
  451          // 使用示例     func_double_to_str(data_buffer, 3.1415, 2);                     // 结果输出 data_buffer =
             - "3.14"
  452          // 备注信息     
  453          //-------------------------------------------------------------------------------------------------------
             -------------
  454          void func_double_to_str (char *str, double number, uint8 point_bit)
  455          {
  456   1          int data_int = 0;                                                           // 整数部分
  457   1          int data_float = 0.0;                                                       // 小数部分
  458   1          int data_temp[12];                                                          // 整数字符缓冲
  459   1          int data_temp_point[9];                                                     // 小数字符缓冲
  460   1          uint8 temp_bit = point_bit;                                                      // 转换精度位数
  461   1          
  462   1              zf_assert(str != NULL);
  463   1          
  464   1              do
  465   1          {
  466   2              if(NULL == str)
  467   2              {
  468   3                  break;
  469   3              }
  470   2      
  471   2              // 提取整数部分
  472   2              data_int = (int)number;                                                 // 直接强制转换为 int
  473   2              if(0 > number)                                                          // 判断源数据是正数还是负
             -数
  474   2              {
  475   3                  *str ++ = '-';
  476   3              }
  477   2              else if(0.0 == number)                                                  // 如果是个 0
  478   2              {

C251 COMPILER V5.60.0,  zf_common_function                                                 24/01/26  11:15:46  PAGE 9   
  479   3                  *str ++ = '0';
  480   3                  *str ++ = '.';
  481   3                  *str = '0';
  482   3                  break;
  483   3              }
  484   2      
  485   2              // 提取小数部分
  486   2              number = number - data_int;                                             // 减去整数部分即可
  487   2              while(temp_bit --)
  488   2              {
  489   3                  number = number * 10;                                               // 将需要的小数位数提取到
             -整数部分
  490   3              }
  491   2              data_float = (int)number;                                               // 获取这部分数值
  492   2      
  493   2              // 整数部分转为字符串
  494   2              temp_bit = 0;
  495   2              do
  496   2              {
  497   3                  data_temp[temp_bit ++] = data_int % 10;                                  // 将整数部分倒序写?
             -胱址缓冲?
  498   3                  data_int /= 10;
  499   3              }while(0 != data_int);
  500   2              while(0 != temp_bit)
  501   2              {
  502   3                  *str ++ = (func_abs(data_temp[temp_bit - 1]) + 0x30);                    // 再倒序将倒序的数?
             -敌慈胱址?得到正序数值
  503   3                  temp_bit --;
  504   3              }
  505   2      
  506   2              // 小数部分转为字符串
  507   2              if(point_bit != 0)
  508   2              {
  509   3                  temp_bit = 0;
  510   3                  *str ++ = '.';
  511   3                  if(0 == data_float)
  512   3                      *str = '0';
  513   3                  else
  514   3                  {
  515   4                      while(0 != point_bit)                                           // 判断有效位数
  516   4                      {
  517   5                          data_temp_point[temp_bit ++] = data_float % 10;                  // 倒序写入字符缓冲?
             -?
  518   5                          data_float /= 10;
  519   5                          point_bit --;                                                
  520   5                      }
  521   4                      while(0 != temp_bit)
  522   4                      {
  523   5                          *str ++ = (func_abs(data_temp_point[temp_bit - 1]) + 0x30);      // 再倒序将倒序的数?
             -敌慈胱址?得到正序数值
  524   5                          temp_bit --;
  525   5                      }
  526   4                  }
  527   3              }
  528   2          }while(0);
  529   1      }
  530          
  531          //-------------------------------------------------------------------------------------------------------
             -------------
  532          // 函数简介     字符串转 Hex
  533          // 参数说明     str             传入字符串 无符号
  534          // 返回参数     uint32          转换后的数据
  535          // 使用示例     uint32 dat = func_str_to_hex("0x11");
  536          // 备注信息     
  537          //-------------------------------------------------------------------------------------------------------
             -------------

C251 COMPILER V5.60.0,  zf_common_function                                                 24/01/26  11:15:46  PAGE 10  
  538          uint32 func_str_to_hex (char *str)
  539          {
  540   1          uint32 str_len = strlen(str);                                               // 字符串长
  541   1          uint32 result_data = 0;                                                     // 结果缓存
  542   1          uint8 temp = 0;                                                             // 计算变量
  543   1          uint8 flag = 0;                                                             // 标志位
  544   1      
  545   1              zf_assert(str != NULL);
  546   1              
  547   1          do
  548   1          {
  549   2              if(NULL == str)
  550   2              {
  551   3                  break;
  552   3              }
  553   2      
  554   2              if(flag)
  555   2              {
  556   3                  if(('a' <= *str) && ('f' >= *str))
  557   3                  {
  558   4                      temp = (*str - 87);
  559   4                  }
  560   3                  else if(('A' <= *str) && ('F' >= *str))
  561   3                  {
  562   4                      temp = (*str - 55);
  563   4                  }
  564   3                  else if(('0' <= *str) && ('9' >= *str))
  565   3                  {
  566   4                      temp = (*str - 48);
  567   4                  }
  568   3                  else
  569   3                  {
  570   4                      break;
  571   4                  }
  572   3                  result_data = ((result_data << 4) | (temp & 0x0F));
  573   3              }
  574   2              else
  575   2              {
  576   3      //            if(strncmp("0x", str, 2))
  577   3                  if((*str == '0') && (*(str + 1) == 'x'))
  578   3                  {
  579   4                      str ++;
  580   4                      flag = 1;
  581   4                  }
  582   3              }
  583   2              str ++;
  584   2          }while(str_len --);
  585   1      
  586   1          return result_data;
  587   1      }
  588          
  589          //-------------------------------------------------------------------------------------------------------
             -------------
  590          // 函数简介     Hex 转字符串
  591          // 参数说明     *str            字符串指针
  592          // 参数说明     number          传入的数据
  593          // 返回参数     void
  594          // 使用示例     func_hex_to_str(data_buffer, 0x11);                             // 结果输出 data_buffer =
             - "0x11"
  595          // 备注信息     
  596          //-------------------------------------------------------------------------------------------------------
             -------------
  597          void func_hex_to_str (char *str, uint32 number)
  598          {
  599   1          const char hex_index[16] = {
  600   1              '0', '1', '2', '3',

C251 COMPILER V5.60.0,  zf_common_function                                                 24/01/26  11:15:46  PAGE 11  
  601   1              '4', '5', '6', '7',
  602   1              '8', '9', 'A', 'B',
  603   1              'C', 'D', 'E', 'F'};
  604   1          int8 data_temp[12];                                                         // 缓冲区
  605   1          uint8 temp_bit = 0;                                                              // 数字位数
  606   1      
  607   1          zf_assert(str != NULL);
  608   1                      
  609   1          *str++ = '0';
  610   1          *str++ = 'x';
  611   1          do
  612   1          {
  613   2              if(NULL == str)
  614   2              {
  615   3                  break;
  616   3              }
  617   2      
  618   2              if(0 == number)                                                         // 这是个 0
  619   2              {
  620   3                  *str = '0';
  621   3                  break;
  622   3              }
  623   2      
  624   2              while(0 != number)                                                      // 循环直到数值归零
  625   2              {
  626   3                  data_temp[temp_bit ++] = (number & 0xF);                                 // 倒序将数值提取出?
             -?
  627   3                  number >>= 4;                                                       // 削减被提取的个位数
  628   3              }
  629   2              while(0 != temp_bit)                                                         // 提取的数字个数递?
             -醮?
  630   2              {
  631   3                  *str ++ = hex_index[data_temp[temp_bit - 1]];                            // 将数字从倒序数组?
             -械剐蛉〕?变成正序放入字符串
  632   3                  temp_bit --;
  633   3              }
  634   2          }while(0);
  635   1      }
  636          
  637          //-------------------------------------------------------------------------------------------------------
             -------------
  638          // 函数简介     数字转换为 ASCII 值
  639          // 参数说明     dat             传入的数据
  640          // 参数说明     *p              数据缓冲
  641          // 参数说明     neg_type        数据类型
  642          // 参数说明     radix           进制
  643          // 返回参数     uint8           数据
  644          // 使用示例     number_conversion_ascii((uint32)ival, vstr, 1, 10);
  645          // 备注信息     本函数在文件内部调用 用户不用关注 也不可修改
  646          //-------------------------------------------------------------------------------------------------------
             -------------
  647          static uint8 number_conversion_ascii (uint32 dat, int8 *p, uint8 neg_type, uint8 radix)
  648          {
  649   1          int32   neg_dat;
  650   1          uint32  pos_dat;
  651   1          uint8   temp_data = 0;
  652   1          uint8   valid_num = 0;
  653   1      
  654   1          if(neg_type)
  655   1          {
  656   2              neg_dat = (int32)dat;
  657   2              if(0 > neg_dat)
  658   2              {
  659   3                  neg_dat = -neg_dat;
  660   3              }
  661   2              while(1)

C251 COMPILER V5.60.0,  zf_common_function                                                 24/01/26  11:15:46  PAGE 12  
  662   2              {
  663   3                  *p = neg_dat%radix + '0';
  664   3                  neg_dat = neg_dat/radix;
  665   3                  valid_num ++;
  666   3      
  667   3                  if(!neg_dat)
  668   3                  {
  669   4                      break;
  670   4                  }
  671   3                  p ++;
  672   3              }
  673   2          }
  674   1          else
  675   1          {
  676   2              pos_dat = dat;
  677   2              while(1)
  678   2              {
  679   3                  temp_data = pos_dat%radix;
  680   3                  if(10 <= temp_data)
  681   3                  {
  682   4                      temp_data += 'A'-10;
  683   4                  }
  684   3                  else
  685   3                  {
  686   4                      temp_data += '0';
  687   4                  }
  688   3      
  689   3                  *p = temp_data;
  690   3      
  691   3                  pos_dat = pos_dat/radix;
  692   3                  valid_num ++;
  693   3      
  694   3                  if(!pos_dat)
  695   3                  {
  696   4                      break;
  697   4                  }
  698   3                  p ++;
  699   3              }
  700   2          }
  701   1          return valid_num;
  702   1      }
  703          
  704          //-------------------------------------------------------------------------------------------------------
             -------------
  705          // 函数简介     printf 显示转换
  706          // 参数说明     *d_buff         缓冲区
  707          // 参数说明     len             长度
  708          // 返回参数     void
  709          // 使用示例     printf_reverse_order(vstr, vlen);
  710          // 备注信息     本函数在文件内部调用 用户不用关注 也不可修改
  711          //-------------------------------------------------------------------------------------------------------
             -------------
  712          static void printf_reverse_order (int8 *d_buff, uint32 len)
  713          {
  714   1          uint32 i;
  715   1          int8  temp_data;
  716   1          for(i = 0; len / 2 > i; i ++)
  717   1          {
  718   2              temp_data = d_buff[len - 1 - i];
  719   2              d_buff[len - 1 -i ] = d_buff[i];
  720   2              d_buff[i] = temp_data; 
  721   2          }
  722   1      }
  723          
  724          
  725          

C251 COMPILER V5.60.0,  zf_common_function                                                 24/01/26  11:15:46  PAGE 13  
  726          //-------------------------------------------------------------------------------------------------------
             -------------
  727          // 函数简介     sprintf 函数实现
  728          // 参数说明     *buffer         缓冲区
  729          // 参数说明             siz                             大小
  730          // 参数说明     *format         源字符串
  731          // 参数说明     args            可变参数列表
  732          // 返回参数     int32          处理后数据长
  733          // 使用示例     zf_sprintf(buff, "Data : %d", 100);
  734          // 备注信息     本函数在文件内部调用 用户不用关注 也不可修改
  735          //-------------------------------------------------------------------------------------------------------
             -------------
  736          int32 vsnprintf(char *buffer, uint32 siz, const char *format, va_list args) 
  737          {
  738   1          uint32 i;
  739   1          char *ptr;
  740   1          int j;
  741   1          int num;
  742   1          char temp[16];
  743   1          int len;
  744   1          int is_negative;
  745   1          char *str;
  746   1          uint32 num_x;
  747   1          char temp_x[9];
  748   1          const char hex_digits[] = "0123456789abcdef";
  749   1      
  750   1          i = 0;
  751   1          ptr = buffer;
  752   1          
  753   1          if (buffer == NULL || format == NULL || siz == 0)
  754   1              {
  755   2              return 0;
  756   2          }
  757   1                      
  758   1          while (*format != '\0' && i < siz - 1) 
  759   1              {
  760   2              if (*format != '%') 
  761   2                      {
  762   3                  *ptr++ = *format++;
  763   3                  i++;
  764   3                  continue;
  765   3              }
  766   2      
  767   2              /* 处理格式符 */
  768   2              format++;
  769   2              switch (*format) 
  770   2                      {
  771   3                  case 'd':
  772   3                      num = va_arg(args, int);
  773   3                      len = 0;
  774   3                      is_negative = 0;
  775   3      
  776   3                      if (num < 0) 
  777   3                                      {
  778   4                          is_negative = 1;
  779   4                          num = -num;
  780   4                      }
  781   3      
  782   3                      /* 数字转字符串 */
  783   3                      do {
  784   4                          temp[len++] = '0' + (num % 10);
  785   4                          num /= 10;
  786   4                      } while (num > 0 && len < (int)sizeof(temp) - 1);
  787   3      
  788   3                      /* 添加负号 */
  789   3                      if (is_negative) 

C251 COMPILER V5.60.0,  zf_common_function                                                 24/01/26  11:15:46  PAGE 14  
  790   3                                      {
  791   4                          temp[len++] = '-';
  792   4                      }
  793   3      
  794   3                      /* 反转字符串 */
  795   3                      for (j = 0; j < len / 2; j++) 
  796   3                                      {
  797   4                          char t = temp[j];
  798   4                          temp[j] = temp[len - j - 1];
  799   4                          temp[len - j - 1] = t;
  800   4                      }
  801   3      
  802   3                      /* 复制到缓冲区 */
  803   3                      for (j = 0; j < len && i < siz - 1; j++) 
  804   3                                      {
  805   4                          *ptr++ = temp[j];
  806   4                          i++;
  807   4                      }
  808   3                      break;
  809   3      
  810   3                  case 's':
  811   3                      str = va_arg(args, char*);
  812   3                      if (str == NULL) 
  813   3                                      {
  814   4                          str = "(null)";
  815   4                      }
  816   3                      
  817   3                      while (*str != '\0' && i < siz - 1) 
  818   3                                      {
  819   4                          *ptr++ = *str++;
  820   4                          i++;
  821   4                      }
  822   3                      break;
  823   3      
  824   3                  case 'c':
  825   3                      *ptr++ = (char)va_arg(args, int);
  826   3                      i++;
  827   3                      break;
  828   3      
  829   3                  case 'x':
  830   3                      num_x = va_arg(args, uint32);
  831   3                      len = 0;
  832   3      
  833   3                      do {
  834   4                          temp_x[len++] = hex_digits[num_x % 16];
  835   4                          num_x /= 16;
  836   4                      } while (num_x > 0 && len < (int)sizeof(temp_x) - 1);
  837   3      
  838   3                      /* 反转字符串 */
  839   3                      for (j = 0; j < len / 2; j++) 
  840   3                                      {
  841   4                          char t = temp_x[j];
  842   4                          temp_x[j] = temp_x[len - j - 1];
  843   4                          temp_x[len - j - 1] = t;
  844   4                      }
  845   3      
  846   3                      /* 复制到缓冲区 */
  847   3                      for (j = 0; j < len && i < siz - 1; j++) 
  848   3                                      {
  849   4                          *ptr++ = temp_x[j];
  850   4                          i++;
  851   4                      }
  852   3                      break;
  853   3      
  854   3                  default:
  855   3                      *ptr++ = *format;

C251 COMPILER V5.60.0,  zf_common_function                                                 24/01/26  11:15:46  PAGE 15  
  856   3                      i++;
  857   3                      break;
  858   3              }
  859   2              format++;
  860   2          }
  861   1      
  862   1          *ptr = '\0';  /* 确保字符串结束 */
  863   1          return (int32)i;
  864   1      }
  865          
  866          //-------------------------------------------------------------------------------------------------------
             -------------
  867          // 函数简介     sprintf 函数实现
  868          // 参数说明     *buff           缓冲区
  869          // 参数说明     *format         源字符串
  870          // 参数说明     ...             可变参数列表
  871          // 返回参数     uint32          处理后数据长
  872          // 使用示例     zf_sprintf(buff, "Data : %d", 100);
  873          // 备注信息     本函数在文件内部调用 用户不用关注 也不可修改
  874          //-------------------------------------------------------------------------------------------------------
             -------------
  875          uint32 zf_sprintf (int8 *buff, const int8 *format, ...)
  876          {
  877   1          uint32 buff_len = 0;
  878   1              va_list arg;
  879   1              va_start(arg, format);
  880   1      
  881   1          while (*format)
  882   1          {
  883   2              int8 ret = *format;
  884   2              if ('%' == ret)
  885   2              {
  886   3                  switch (*++ format)
  887   3                  {
  888   4                      case 'a':// 十六进制p计数法输出浮点数 暂未实现
  889   4                          {
  890   5                          }
  891   4                          break;
  892   4      
  893   4                      case 'c':// 一个字符
  894   4                          {
  895   5                              int8 ch = (int8)va_arg(arg, uint32);
  896   5                              *buff = ch;
  897   5                              buff ++;
  898   5                              buff_len ++;
  899   5                          }
  900   4                          break;
  901   4      
  902   4                      case 'd':
  903   4                      case 'i':// 有符号十进制整数
  904   4                          {
  905   5                              int8 vstr[33];
  906   5                              int32 ival = (int32)va_arg(arg, int32);
  907   5                              uint8 vlen = number_conversion_ascii((uint32)ival, vstr, 1, 10);
  908   5      
  909   5                              if(0 > ival)  
  910   5                              {
  911   6                                  vstr[vlen] = '-';
  912   6                                  vlen ++;
  913   6                              }
  914   5                              printf_reverse_order(vstr, vlen);
  915   5                              memcpy(buff, vstr, vlen);
  916   5                              buff += vlen;
  917   5                              buff_len += vlen;
  918   5                          }
  919   4                          break;

C251 COMPILER V5.60.0,  zf_common_function                                                 24/01/26  11:15:46  PAGE 16  
  920   4      
  921   4                      case 'f':// 浮点数，输出小数点后六位  不能指定输出精度
  922   4                      case 'F':// 浮点数，输出小数点后六位  不能指定输出精度
  923   4                      {
  924   5                          int8 vstr[33];
  925   5                          double ival = (double)va_arg(arg, double);
  926   5                          uint8 vlen = number_conversion_ascii((uint32)(int32)ival, vstr, 1, 10);
  927   5      
  928   5                          if(0 > ival)  
  929   5                          {
  930   6                              vstr[vlen] = '-';
  931   6                              vlen ++;
  932   6                          }
  933   5                          printf_reverse_order(vstr, vlen);
  934   5                          memcpy(buff, vstr, vlen);
  935   5                          buff += vlen;
  936   5                          buff_len += vlen;
  937   5      
  938   5                          ival = ((double)ival - (int32)ival)*1000000;
  939   5                          if(ival)
  940   5                          {
  941   6                              vlen = number_conversion_ascii((uint32)(int32)ival, vstr, 1, 10);
  942   6                          }
  943   5                          else
  944   5                          {
  945   6                              vstr[0] = vstr[1] = vstr[2] = vstr[3] = vstr[4] = vstr[5] = '0';
  946   6                              vlen = 6;
  947   6                          }
  948   5      
  949   5                          while(6 > vlen)
  950   5                          {
  951   6                              vstr[vlen] = '0';
  952   6                              vlen ++;
  953   6                          }
  954   5      
  955   5                          vstr[vlen] = '.';
  956   5                          vlen ++;
  957   5      
  958   5                          printf_reverse_order(vstr, vlen);
  959   5                          memcpy(buff, vstr, vlen);
  960   5                          buff += vlen;
  961   5                          buff_len += vlen;
  962   5                      }
  963   4                      break;
  964   4      
  965   4                      case 'u':// 无符号十进制整数
  966   4                          {
  967   5                              int8 vstr[33];
  968   5                              uint32 ival = (uint32)va_arg(arg, uint32);
  969   5                              uint8 vlen = number_conversion_ascii(ival, vstr, 0, 10);
  970   5      
  971   5                              printf_reverse_order(vstr, vlen);
  972   5                              memcpy(buff, vstr, vlen);
  973   5                              buff += vlen;
  974   5                              buff_len += vlen;
  975   5                          }
  976   4                          break;
  977   4      
  978   4                      case 'o':// 无符号八进制整数 
  979   4                          {
  980   5                              int8 vstr[33];
  981   5                              uint32 ival = (uint32)va_arg(arg, uint32);
  982   5                              uint8 vlen = number_conversion_ascii(ival, vstr, 0, 8);
  983   5      
  984   5                              printf_reverse_order(vstr, vlen);
  985   5                              memcpy(buff, vstr, vlen);

C251 COMPILER V5.60.0,  zf_common_function                                                 24/01/26  11:15:46  PAGE 17  
  986   5                              buff += vlen;
  987   5                              buff_len += vlen;
  988   5      
  989   5                          }
  990   4                          break;
  991   4      
  992   4                      case 'x':// 无符号十六进制整数
  993   4                      case 'X':// 无符号十六进制整数
  994   4                          {
  995   5                              int8 vstr[33];
  996   5                              uint32 ival = (uint32)va_arg(arg, uint32);
  997   5                              uint8 vlen = number_conversion_ascii(ival, vstr, 0, 16);
  998   5      
  999   5                              printf_reverse_order(vstr, vlen);
 1000   5                              memcpy(buff, vstr, vlen);
 1001   5                              buff += vlen;
 1002   5                              buff_len += vlen;
 1003   5                          }
 1004   4                          break;
 1005   4      
 1006   4                      case 's':// 字符串
 1007   4                          {
 1008   5                              int8 *pc = va_arg(arg, int8 *);
 1009   5                              while (*pc)
 1010   5                              {
 1011   6                                  *buff = *pc;
 1012   6                                  buff ++;
 1013   6                                  buff_len ++;
 1014   6                                  pc ++;
 1015   6                              }
 1016   5                          }
 1017   4                          break;
 1018   4      
 1019   4                      case 'p':// 以16进制形式输出指针
 1020   4                          {
 1021   5                              int8 vstr[33];
 1022   5                              uint32 ival = (uint32)va_arg(arg, uint32);
 1023   5                              //uint8 vlen = number_conversion_ascii(ival, vstr, 0, 16);
 1024   5                              number_conversion_ascii(ival, vstr, 0, 16);
 1025   5                              printf_reverse_order(vstr, 8);
 1026   5                              memcpy(buff, vstr, 8);
 1027   5                              buff += 8;
 1028   5                              buff_len += 8;
 1029   5                          }
 1030   4                          break;
 1031   4      
 1032   4                      case '%':// 输出字符% 
 1033   4                          {
 1034   5                              *buff = '%';
 1035   5                              buff ++;
 1036   5                              buff_len ++;
 1037   5                          }
 1038   4                          break;
 1039   4      
 1040   4                      default:
 1041   4                          break;
 1042   4                  }
 1043   3              }
 1044   2              else
 1045   2              {
 1046   3                  *buff = (int8)(*format);
 1047   3                  buff ++;
 1048   3                  buff_len ++;
 1049   3              }
 1050   2              format ++;
 1051   2          }

C251 COMPILER V5.60.0,  zf_common_function                                                 24/01/26  11:15:46  PAGE 18  
 1052   1          va_end(arg);
 1053   1      
 1054   1          return buff_len;
 1055   1      }
 1056          
 1057          


Module Information          Static   Overlayable
------------------------------------------------
  code size            =     10220     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =       477     ------
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =        87     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

