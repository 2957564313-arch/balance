#include "zf_common_headfile.h"

// =================================================================
// 定时器中断时间（针对 STC32G @ 35MHz）
// =================================================================

void Init_Timer0_100us(void)
{
    // Timer0: 16位自动重装载，1T模式
    // 在 35MHz 下 100us = 3500 个时钟周期
    // 初值 = 65536 - 3500 = 62036 (0xF254)
    
    AUXR |= 0x80;    // 设置定时器0为1T模式
    TMOD &= 0xF0;    // 设置定时器0为模式0（16位自动重装载）

    TL0 = 0x54;      // 低8位 (0xF254)
    TH0 = 0xF2;      // 高8位 (0xF254)

    TF0 = 0;         // 清定时器0溢出标志
    TR0 = 1;         // 启动定时器0
    ET0 = 1;         // 使能定时器0中断
}

void Init_Timer2_5ms(void)
{
    // Timer2: 16位自动重装载
    // 在 35MHz 下 1T 模式无法精确产生 5ms（最小约 1.87ms），
    // 因此采用 12T 模式降频：35M/12 ≈ 2.9166MHz
    // 5ms 对应计数约 14583
    // 初值 = 65536 - 14583 = 50953 (0xC709)
    // 取整后会有微小误差
    
    AUXR &= ~(1<<2); // Bit2=0: 定时器2为12T模式（降频）

    T2L = 0x09;      // 低8位 (0xC709)
    T2H = 0xC7;      // 高8位 (0xC709)

    AUXR |= (1<<4);  // Bit4=1: 启动定时器2 (T2R)
    IE2  |= (1<<2);  // Bit2=1: 使能定时器2中断 (ET2)
}

// =================================================================
// 中断服务函数
// =================================================================

// 1. 定时器0中断 (100us) -> 软编码器扫描
void timer0_isr(void) interrupt 1 
{
    Soft_Encoder_Scan(); 
}

// 2. 定时器2中断 (5ms) -> 平衡任务调度
void timer2_isr(void) interrupt 12
{
    // STC32G 的定时器中断标志由硬件处理，无需在此手动清除

    Balance_Task(); // 执行平衡任务
    Key_Tick();     // 按键定时处理

    // 注意：不要在中断中调用耗时的函数，例如 printf 或 OLED_Show
}

// =================================================================
// 主程序
// =================================================================
void main(void)
{
    // 1. 系统时钟初始化（目标 35MHz）
    // 如果 zf_common_clock.h 中没有定义 SYSTEM_CLOCK_35M，可直接调用 clock_init(35000000);
    clock_init(SYSTEM_CLOCK_35M);
    
    // 2. 调试输出设备初始化（用于打印信息）
    debug_init(); 

    // 3. 外设初始化
    LED_Init();    // LED 初始化
    Buzzer_Init(); // 蜂鸣器初始化
    Motor_Init();  // 电机驱动 & 编码器初始化
    BT_Init();     // 蓝牙初始化
    OLED_Init();   // 屏幕初始化
    Key_Init();    // 按键初始化
    
    // 4. 应用层初始化
    Param_Init();  // 读取 Flash 参数（恢复 PID）
    Mode_Init();   // 模式初始化 & 任务设置
    Balance_Init();// 平衡算法初始化（PID & IMU，假设校准已完成）
    
    // 发出启动提示音
    Buzzer_Beep(200);
    
    // 5. 初始化定时器（启用中断）
    Init_Timer0_100us();
    Init_Timer2_5ms();
    
    // 6. 使能全局中断
    EA = 1; 

    // 7. 主循环（空闲任务优先调度）
    while(1)
    {
        // 处理蓝牙接收缓冲
        BT_Check_Rx();
        
        // 响应按键事件（例如 Mode 4）
        // 将按键事件记录到中断或缓冲，由 main 统一处理
        {
            uint8 key = Key_Check_Simple(); 

            if(key) Mode_Path_Key_Handler(key);
        }
        
        // 屏幕刷新（如无必要可不刷新）
        // Menu_Show(); 
        
        // 示例：每 500ms 切换一次 LED
        // LED_TOGGLE(); system_delay_ms(500); 
    }
}
